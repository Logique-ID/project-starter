<!-- Generated by SpecStory, Markdown v2.1.0 -->

<!-- cursor Session e49a6ada-dab8-4550-9c83-0622ef7c240a (2026-01-14 09:11Z) -->

# Cursor rules to Mason variable (2026-01-14 09:11Z)

_**User (2026-01-14 07:24Z)**_

@src/__brick__/{{project_name}}/.cursor look at rules right here, convert it using mason variable

---

_**Agent (model default, mode Agent)**_

<think><details><summary>Thought Process</summary>
**Inspecting project structure**

The user wants to use mason variables in the brick cursor rules instead of hardcoding values. I need to check that folder and plan how to implement changes, using functions like list_dir and read_file. I'll make sure to use absolute paths as I work. It seems we will need to template the derived-cursor-rules to reference the {{project_name}} variables. First, I'll look at the contents of that folder’s rules by listing its directory.</details></think>

---

I’ll first inspect the `.cursor/rules` inside the brick, compare it to the root rules, then update those rule files to use Mason variables instead of hardcoded names/paths. I’ll implement the changes directly once I see how your project name and flavors are supposed to be templated.

---

<tool-use data-tool-type="generic" data-tool-name="list_dir">
<details>
            <summary>Tool use: **list_dir** • Listed directory, 0 results</summary>
        
No results found
</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: /Users/cirimin/Logique/Project Starter/project-starter/.cursor/rules/derived-cursor-rules.mdc</summary>

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Converting project files**

The user wants to convert their files to use a masonry variable in brick .cursor/rules. Currently, these five files appear to be copies of the original rules but haven't been updated with variables. I’ll need to open each of these files and replace the project name, paths, and such with the {{project_name}} placeholder. I can use the read_file function on each one to start this process.</details></think>

---

I’ve inspected the main derived rules and located the brick’s rules directory; next I’ll open each brick rule file and update any hardcoded names/paths to use Mason variables like `{{project_name}}` so they work in generated projects.

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: /Users/cirimin/Logique/Project Starter/project-starter/src/__brick__/{{project_name}}/.cursor/rules/dart-conventions.mdc</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: /Users/cirimin/Logique/Project Starter/project-starter/src/__brick__/{{project_name}}/.cursor/rules/flutter-ui-patterns.mdc</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: /Users/cirimin/Logique/Project Starter/project-starter/src/__brick__/{{project_name}}/.cursor/rules/project-structure.mdc</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: /Users/cirimin/Logique/Project Starter/project-starter/src/__brick__/{{project_name}}/.cursor/rules/riverpod-patterns.mdc</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: /Users/cirimin/Logique/Project Starter/project-starter/src/__brick__/{{project_name}}/.cursor/rules/routing-patterns.mdc</summary>

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Considering project conversion**

I’ve noticed some hardcoded elements like the package name `mm2100_mobile`, the app title MM2100 Mobile, and pubspec flavors. The user wants to convert this using Mason variables. For the cursor rules in the generated project, I shouldn't mention mm2100_mobile directly but rather use placeholders like `{{project_name.snakeCase()}}` or `{{package_name}}`, depending on the variables defined in the brick. I need to check `src/brick.yaml` to see the available variables.</details></think>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: /Users/cirimin/Logique/Project Starter/project-starter/src/brick.yaml</summary>

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Templating project variables**

I'm thinking we can use `{{project_name}}` in snake_case and `{{app_name}}` for display purposes. When generalizing the rules, like in dart-conventions for import examples, we should change specific project references to something more generic. For instance, I should replace `package:mm2100_mobile/...` with `package:{{project_name}}/...`. In flutter-ui-patterns, it'd be alright to have some feature-specific names but must ensure imports get templated. With pubspec flavors, we'd want to use `{{app_id}}` for app IDs. The brick rules should already accommodate these templates in the generated project files.
**Editing project files**

I need to make some edits to the files, replacing each occurrence of `mm2100_mobile` with `{{project_name}}`. Instead of "MM2100 Mobile Project Structure," I could use "{{app_name}} Project Structure" or just "Project Structure" for simplicity. App IDs like `id.logique.mm2100.dev` should be switched to `{{app_id}}.dev`, depending on conventions. It might be prudent to use general descriptors for development, staging, and production environments. The user mentioned using mason variable, which suggests we'll focus on package names and project name strings while avoiding specific IDs and absolute paths from my machine.
**Reviewing brick rules for templating**

I’m examining the brick rules for dart, flutter-ui, and project structure, which reference mm2100 and its flavors. I need to go through the project structure for specific names, like `MM2100 Mobile Project Structure`, and flavors app IDs. Additionally, in flutter-ui-patterns, I noticed some imports like `package:mm2100_mobile/...` that also need to be templated. I should also check the Riverpod patterns for any references to package imports, perhaps using grep for a quick scan as the instructions suggest.</details></think>

---

<tool-use data-tool-type="search" data-tool-name="grep">
<details>
<summary>Tool use: **grep** • Grep for "mm2100" in "/Users/cirimin/Logique/Project Starter/project-starter/src/__brick__/{{project_name}}/.cursor/rules" • 5 matches</summary>

Output mode: content


| File | Content | Line |
|------|------|------|
| `src/__brick__/\{{project_name\}}/.cursor/rules/project-structure.mdc` | `- **dev**: Development environment (`id.logique.mm2100.dev`)` | L64 |
| `src/__brick__/\{{project_name\}}/.cursor/rules/project-structure.mdc` | `- **stg**: Staging environment (`id.logique.mm2100.stg`)` | L65 |
| `src/__brick__/\{{project_name\}}/.cursor/rules/project-structure.mdc` | `- **prod**: Production environment (`id.logique.mm2100`)` | L66 |
| `src/__brick__/\{{project_name\}}/.cursor/rules/flutter-ui-patterns.mdc` | `import 'package:mm2100_mobile/src/feature/task/presentation/widget/item_task_widget.dart';` | L886 |
| `src/__brick__/\{{project_name\}}/.cursor/rules/dart-conventions.mdc` | `import 'package:mm2100_mobile/src/theme/app_color_theme.dart';` | L70 |


</details>
</tool-use>

---



---

<tool-use data-tool-type="unknown" data-tool-name="apply_patch">
<details>
<summary>Tool use: **apply_patch**</summary>


Parameters:

```json
{
  "relativeWorkspacePath": "/Users/cirimin/Logique/Project Starter/project-starter/src/__brick__/{{project_name}}/.cursor/rules/dart-conventions.mdc"
}
```
Additional data:

```json
{
  "reasonForAcceptReject": {
    "type": "restrictedFile"
  },
  "codeblockId": "d0c6ab40-232d-4a00-bee0-c40158baf54c",
  "codeblock": {
    "uri": {
      "scheme": "file",
      "authority": "",
      "path": "/Users/cirimin/Logique/Project Starter/project-starter/src/__brick__/{{project_name}}/.cursor/rules/dart-conventions.mdc",
      "query": "",
      "fragment": "",
      "_formatted": "file:///Users/cirimin/Logique/Project%20Starter/project-starter/src/__brick__/%7B%7Bproject_name%7D%7D/.cursor/rules/dart-conventions.mdc",
      "_fsPath": "/Users/cirimin/Logique/Project Starter/project-starter/src/__brick__/{{project_name}}/.cursor/rules/dart-conventions.mdc"
    },
    "codeblockId": "d0c6ab40-232d-4a00-bee0-c40158baf54c",
    "codeBlockIdx": 0,
    "content": "---\nglobs: *.dart\n---\n# Dart Code Conventions\n\n## Code Style\n\n- Follow Dart style guide and Flutter conventions\n- Use &#96;prefer_const_constructors&#96; and &#96;prefer_const_literals_to_create_immutables&#96; (configured in [analysis_options.yaml](mdc:analysis_options.yaml))\n- Prefer single quotes for strings (when consistent with existing code)\n- Always use semicolons\n\n## Variable Declarations\n\n**Avoid &#96;var&#96; and &#96;dynamic&#96;** - Always use explicit types or &#96;final&#96;:\n\n- ✅ **Use &#96;final&#96;** for variables that won't be reassigned (preferred)\n- ✅ **Use explicit type** when the type is important or when reassignment is needed\n- ❌ **Avoid &#96;var&#96;** - Use &#96;final&#96; or explicit type instead\n- ❌ **Avoid &#96;dynamic&#96;** - Use explicit type or &#96;Object?&#96; if type is unknown\n\n**Examples:**\n\n&#96;&#96;&#96;dart\n// ✅ Correct: Use final with explicit type\nfinal String name = 'John';\nfinal int count = 42;\nfinal List&lt;String&gt; items = ['a', 'b'];\n\n// ✅ Correct: Use final with type inference (when type is obvious)\nfinal name = 'John'; // String is inferred\nfinal count = 42; // int is inferred\n\n// ✅ Correct: Use explicit type when reassignment is needed\nString message = 'Hello';\nmessage = 'World';\n\n// ❌ Wrong: Avoid var\nvar name = 'John'; // Use final instead\nvar count = 42; // Use final instead\n\n// ❌ Wrong: Avoid dynamic\ndynamic data = fetchData(); // Use explicit type or Object? instead\nObject? data = fetchData(); // Better alternative\n&#96;&#96;&#96;\n\n**When to use explicit type vs final:**\n- Use &#96;final&#96; when the variable won't be reassigned (most cases)\n- Use explicit type when:\n  - The variable will be reassigned\n  - The type is not obvious from the initializer\n  - You want to make the type explicit for clarity\n\n## Imports\n\nOrganize imports in this order:\n1. Dart SDK imports\n2. Flutter imports\n3. Package imports (third-party)\n4. Project imports (relative imports with &#96;package:&#96;)\n\nExample:\n&#96;&#96;&#96;dart\nimport 'dart:async';\n\nimport 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\nimport 'package:flutter_screenutil/flutter_screenutil.dart';\n\nimport 'package:{{project_name}}/src/theme/app_color_theme.dart';\n&#96;&#96;&#96;\n\n## File Naming\n\n- Use &#96;snake_case&#96; for file names\n- Screen files: &#96;*_screen.dart&#96;\n- Sub-screen files: &#96;*_subscreen.dart&#96;\n- Widget files: &#96;*_widget.dart&#96;\n- Repository files: &#96;*_repository.dart&#96;\n- Controller files: &#96;*_controller.dart&#96;, &#96;*_event.dart&#96;, &#96;*_state.dart&#96;\n- Model files: &#96;*_response.dart&#96;, &#96;*_model.dart&#96;, etc.\n\n## Model Classes and JSON Serialization\n\n**Prefer &#96;num&#96; over &#96;int&#96; or &#96;double&#96;** for numeric fields in model classes that are used for JSON API conversion.\n\nThis is especially important because JSON responses may return:\n- &#96;2&#96; (integer) when the decimal is 0\n- &#96;2.0&#96; (double) when the decimal is present\n- &#96;2.5&#96; (double) when there's a fractional part\n\nUsing &#96;num&#96; handles all these cases gracefully.\n\n**Examples:**\n\n&#96;&#96;&#96;dart\n// ✅ Correct: Use num for numeric fields in JSON models\nclass ProductResponse {\n  final num price;\n  final num quantity;\n  final num? discount; // nullable if optional\n  \n  ProductResponse({\n    required this.price,\n    required this.quantity,\n    this.discount,\n  });\n  \n  factory ProductResponse.fromJson(Map&lt;String, dynamic&gt; json) {\n    return ProductResponse(\n      price: json['price'] as num, // Handles both 2 and 2.0\n      quantity: json['quantity'] as num,\n      discount: json['discount'] as num?,\n    );\n  }\n}\n\n// ❌ Wrong: Using int or double may cause parsing errors\nclass ProductResponse {\n  final int price; // May fail if JSON returns 2.0\n  final double quantity; // May fail if JSON returns 2\n}\n&#96;&#96;&#96;\n\n**When to use &#96;int&#96; or &#96;double&#96; explicitly:**\n- Use &#96;int&#96; when the value is guaranteed to always be an integer (e.g., IDs, counts)\n- Use &#96;double&#96; when the value is guaranteed to always have decimals (e.g., percentages, coordinates)\n- Use &#96;num&#96; when the value can be either (e.g., prices, measurements, API numeric fields)\n\n## Code Generation\n\n- Files using &#96;@riverpod&#96; or &#96;@Riverpod&#96; annotations must have a corresponding &#96;.g.dart&#96; file\n- Always include &#96;part 'filename.g.dart';&#96; at the top of files that need code generation\n- Run &#96;flutter pub run build_runner build --delete-conflicting-outputs&#96; after adding/modifying providers\n- Never manually edit &#96;.g.dart&#96; files\n\n## Widget Conventions\n\n- Use &#96;const&#96; constructors whenever possible\n- Prefer &#96;ConsumerWidget&#96; or &#96;ConsumerStatefulWidget&#96; for widgets that need Riverpod\n- Use mixins for shared behavior (e.g., &#96;HomeEvent&#96;, &#96;HomeState&#96;)\n- Extract reusable widgets to &#96;common_widget/&#96; or feature-specific &#96;widget/&#96; folders\n\n## Error Handling\n\n- Use &#96;AsyncValue&#96; from Riverpod for async state management\n- Handle errors gracefully with proper error widgets\n- Use [AsyncValueWidget](mdc:lib/src/common_widget/async_value_widget.dart) for displaying async data\n",
    "languageId": "markdown"
  }
}
```
Result:

```json
{
  "diff": {
    "chunks": [
      {
        "diffString": "  import 'package:flutter_screenutil/flutter_screenutil.dart';\n  \n- import 'package:mm2100_mobile/src/theme/app_color_theme.dart';\n+ import 'package:{{project_name}}/src/theme/app_color_theme.dart';\n  &#96;&#96;&#96;\n  ",
        "oldStart": 68,
        "newStart": 68,
        "oldLines": 5,
        "newLines": 5,
        "linesRemoved": 1,
        "linesAdded": 1
      }
    ],
    "editor": "EDITOR_AI"
  },
  "shouldAutoFixLints": true,
  "resultForModel": "Success. Updated the following files:\nM /Users/cirimin/Logique/Project Starter/project-starter/src/__brick__/{{project_name}}/.cursor/rules/dart-conventions.mdc",
  "contentsAfterEdit": "---\nglobs: *.dart\n---\n# Dart Code Conventions\n\n## Code Style\n\n- Follow Dart style guide and Flutter conventions\n- Use &#96;prefer_const_constructors&#96; and &#96;prefer_const_literals_to_create_immutables&#96; (configured in [analysis_options.yaml](mdc:analysis_options.yaml))\n- Prefer single quotes for strings (when consistent with existing code)\n- Always use semicolons\n\n## Variable Declarations\n\n**Avoid &#96;var&#96; and &#96;dynamic&#96;** - Always use explicit types or &#96;final&#96;:\n\n- ✅ **Use &#96;final&#96;** for variables that won't be reassigned (preferred)\n- ✅ **Use explicit type** when the type is important or when reassignment is needed\n- ❌ **Avoid &#96;var&#96;** - Use &#96;final&#96; or explicit type instead\n- ❌ **Avoid &#96;dynamic&#96;** - Use explicit type or &#96;Object?&#96; if type is unknown\n\n**Examples:**\n\n&#96;&#96;&#96;dart\n// ✅ Correct: Use final with explicit type\nfinal String name = 'John';\nfinal int count = 42;\nfinal List&lt;String&gt; items = ['a', 'b'];\n\n// ✅ Correct: Use final with type inference (when type is obvious)\nfinal name = 'John'; // String is inferred\nfinal count = 42; // int is inferred\n\n// ✅ Correct: Use explicit type when reassignment is needed\nString message = 'Hello';\nmessage = 'World';\n\n// ❌ Wrong: Avoid var\nvar name = 'John'; // Use final instead\nvar count = 42; // Use final instead\n\n// ❌ Wrong: Avoid dynamic\ndynamic data = fetchData(); // Use explicit type or Object? instead\nObject? data = fetchData(); // Better alternative\n&#96;&#96;&#96;\n\n**When to use explicit type vs final:**\n- Use &#96;final&#96; when the variable won't be reassigned (most cases)\n- Use explicit type when:\n  - The variable will be reassigned\n  - The type is not obvious from the initializer\n  - You want to make the type explicit for clarity\n\n## Imports\n\nOrganize imports in this order:\n1. Dart SDK imports\n2. Flutter imports\n3. Package imports (third-party)\n4. Project imports (relative imports with &#96;package:&#96;)\n\nExample:\n&#96;&#96;&#96;dart\nimport 'dart:async';\n\nimport 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\nimport 'package:flutter_screenutil/flutter_screenutil.dart';\n\nimport 'package:{{project_name}}/src/theme/app_color_theme.dart';\n&#96;&#96;&#96;\n\n## File Naming\n\n- Use &#96;snake_case&#96; for file names\n- Screen files: &#96;*_screen.dart&#96;\n- Sub-screen files: &#96;*_subscreen.dart&#96;\n- Widget files: &#96;*_widget.dart&#96;\n- Repository files: &#96;*_repository.dart&#96;\n- Controller files: &#96;*_controller.dart&#96;, &#96;*_event.dart&#96;, &#96;*_state.dart&#96;\n- Model files: &#96;*_response.dart&#96;, &#96;*_model.dart&#96;, etc.\n\n## Model Classes and JSON Serialization\n\n**Prefer &#96;num&#96; over &#96;int&#96; or &#96;double&#96;** for numeric fields in model classes that are used for JSON API conversion.\n\nThis is especially important because JSON responses may return:\n- &#96;2&#96; (integer) when the decimal is 0\n- &#96;2.0&#96; (double) when the decimal is present\n- &#96;2.5&#96; (double) when there's a fractional part\n\nUsing &#96;num&#96; handles all these cases gracefully.\n\n**Examples:**\n\n&#96;&#96;&#96;dart\n// ✅ Correct: Use num for numeric fields in JSON models\nclass ProductResponse {\n  final num price;\n  final num quantity;\n  final num? discount; // nullable if optional\n  \n  ProductResponse({\n    required this.price,\n    required this.quantity,\n    this.discount,\n  });\n  \n  factory ProductResponse.fromJson(Map&lt;String, dynamic&gt; json) {\n    return ProductResponse(\n      price: json['price'] as num, // Handles both 2 and 2.0\n      quantity: json['quantity'] as num,\n      discount: json['discount'] as num?,\n    );\n  }\n}\n\n// ❌ Wrong: Using int or double may cause parsing errors\nclass ProductResponse {\n  final int price; // May fail if JSON returns 2.0\n  final double quantity; // May fail if JSON returns 2\n}\n&#96;&#96;&#96;\n\n**When to use &#96;int&#96; or &#96;double&#96; explicitly:**\n- Use &#96;int&#96; when the value is guaranteed to always be an integer (e.g., IDs, counts)\n- Use &#96;double&#96; when the value is guaranteed to always have decimals (e.g., percentages, coordinates)\n- Use &#96;num&#96; when the value can be either (e.g., prices, measurements, API numeric fields)\n\n## Code Generation\n\n- Files using &#96;@riverpod&#96; or &#96;@Riverpod&#96; annotations must have a corresponding &#96;.g.dart&#96; file\n- Always include &#96;part 'filename.g.dart';&#96; at the top of files that need code generation\n- Run &#96;flutter pub run build_runner build --delete-conflicting-outputs&#96; after adding/modifying providers\n- Never manually edit &#96;.g.dart&#96; files\n\n## Widget Conventions\n\n- Use &#96;const&#96; constructors whenever possible\n- Prefer &#96;ConsumerWidget&#96; or &#96;ConsumerStatefulWidget&#96; for widgets that need Riverpod\n- Use mixins for shared behavior (e.g., &#96;HomeEvent&#96;, &#96;HomeState&#96;)\n- Extract reusable widgets to &#96;common_widget/&#96; or feature-specific &#96;widget/&#96; folders\n\n## Error Handling\n\n- Use &#96;AsyncValue&#96; from Riverpod for async state management\n- Handle errors gracefully with proper error widgets\n- Use [AsyncValueWidget](mdc:lib/src/common_widget/async_value_widget.dart) for displaying async data\n"
}
```
User decision: **accepted**

Status: **completed**


</details>
</tool-use>

---

<tool-use data-tool-type="unknown" data-tool-name="apply_patch">
<details>
<summary>Tool use: **apply_patch**</summary>


Parameters:

```json
{
  "relativeWorkspacePath": "/Users/cirimin/Logique/Project Starter/project-starter/src/__brick__/{{project_name}}/.cursor/rules/flutter-ui-patterns.mdc"
}
```
Additional data:

```json
{
  "reasonForAcceptReject": {
    "type": "restrictedFile"
  },
  "codeblockId": "a5409535-185b-4857-9d19-306094e5f535",
  "codeblock": {
    "uri": {
      "scheme": "file",
      "authority": "",
      "path": "/Users/cirimin/Logique/Project Starter/project-starter/src/__brick__/{{project_name}}/.cursor/rules/flutter-ui-patterns.mdc",
      "query": "",
      "fragment": "",
      "_formatted": "file:///Users/cirimin/Logique/Project%20Starter/project-starter/src/__brick__/%7B%7Bproject_name%7D%7D/.cursor/rules/flutter-ui-patterns.mdc",
      "_fsPath": "/Users/cirimin/Logique/Project Starter/project-starter/src/__brick__/{{project_name}}/.cursor/rules/flutter-ui-patterns.mdc"
    },
    "codeblockId": "a5409535-185b-4857-9d19-306094e5f535",
    "codeBlockIdx": 0,
    "content": "---\nglobs: **/presentation/**/*.dart,**/common_widget/**/*.dart\n---\n# Flutter UI Patterns\n\n## Responsive Design\n\nAlways use **Flutter ScreenUtil** for responsive sizing:\n\n- Width: &#96;.w&#96; extension (e.g., &#96;16.w&#96;)\n- Height: &#96;.h&#96; extension (e.g., &#96;24.h&#96;)\n- Font size: &#96;.sp&#96; extension (e.g., &#96;14.sp&#96;)\n- Radius: &#96;.r&#96; extension (e.g., &#96;8.r&#96;)\n\nDesign size is configured in [app.dart](mdc:lib/src/app.dart) as &#96;Size(360, 800)&#96;.\n\n## Spacing\n\nUse predefined gap constants from [app_sizes.dart](mdc:lib/src/theme/app_sizes.dart):\n\n- Horizontal gaps: &#96;gapW4&#96;, &#96;gapW8&#96;, &#96;gapW12&#96;, &#96;gapW16&#96;, etc.\n- Vertical gaps: &#96;gapH4&#96;, &#96;gapH8&#96;, &#96;gapH12&#96;, &#96;gapH16&#96;, etc.\n\nExample:\n&#96;&#96;&#96;dart\nColumn(\n  children: [\n    Text('Title'),\n    gapH16,\n    Text('Content'),\n  ],\n)\n&#96;&#96;&#96;\n\n## Theming\n\nUse theme constants from:\n\n- **Colors**: [app_color_theme.dart](mdc:lib/src/theme/app_color_theme.dart) - &#96;AppColorTheme.primary500&#96;, etc.\n- **Text Styles**: [app_text_theme.dart](mdc:lib/src/theme/app_text_theme.dart) - &#96;AppTextTheme.boldBase&#96;, etc.\n- **Sizes**: [app_sizes.dart](mdc:lib/src/theme/app_sizes.dart) - &#96;Sizes.p16&#96;, etc.\n\nExample:\n&#96;&#96;&#96;dart\nText(\n  'Hello',\n  style: AppTextTheme.boldBase.copyWith(\n    color: AppColorTheme.primary500,\n  ),\n)\n&#96;&#96;&#96;\n\n## Localization\n\nAlways use localization for user-facing strings:\n\n1. **Use &#96;LocalizationMixin&#96;** - The preferred way to access localization in UI layer\n2. Use generated keys: &#96;loc.appTitle&#96;, &#96;loc.view_all&#96;, etc.\n3. Add translations to &#96;.arb&#96; files in &#96;lib/src/localization/&#96;\n4. Run &#96;flutter gen-l10n&#96; to generate localization classes\n\n### Using LocalizationMixin\n\nThe [LocalizationMixin](mdc:lib/src/core/mixins/localization_mixin.dart) provides all localization operations:\n\n&#96;&#96;&#96;dart\n// ✅ Correct: Use LocalizationMixin in UI layer\nclass HomeSubscreen extends ConsumerWidget with HomeEvent, HomeState, LocalizationMixin {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final loc = getLocalizations(ref); // Get AppLocalizations\n    final locale = getLocale(ref); // Get locale string ('en' or 'id')\n    final localeNumber = getLocaleToNumber(ref); // Get locale number (en=2, id=1)\n    \n    // Change locale\n    await setLocalization('en', ref);\n    \n    return Text(loc.appTitle);\n  }\n}\n&#96;&#96;&#96;\n\n**Available methods:**\n- &#96;getLocalizations(WidgetRef ref)&#96; - Returns &#96;AppLocalizations&#96; instance\n- &#96;getLocale(WidgetRef ref)&#96; - Returns locale string ('en' or 'id')\n- &#96;getLocaleToNumber(WidgetRef ref)&#96; - Returns locale number (en=2, id=1)\n- &#96;setLocalization(String locale, WidgetRef ref)&#96; - Changes app locale\n\n**Note**: Event/State mixins can use &#96;ref.watch(appLocalizationsProvider)&#96; directly since they're not UI layer files.\n\nNever hardcode user-facing strings. See [string_hardcoded.dart](mdc:lib/src/localization/string_hardcoded.dart) for exceptions.\n\n## Widget Structure\n\n### Screen Widgets\n\n- Use &#96;ConsumerWidget&#96; or &#96;ConsumerStatefulWidget&#96; for Riverpod integration\n- Use mixins for shared behavior (e.g., &#96;with HomeEvent, HomeState&#96;)\n- Extract complex UI into separate widget methods (prefixed with &#96;_&#96;)\n\nExample from [home_subscreen.dart](mdc:lib/src/feature/home/presentation/home_subscreen.dart):\n&#96;&#96;&#96;dart\nclass HomeSubscreen extends ConsumerWidget with HomeEvent, HomeState, LocalizationMixin {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final loc = getLocalizations(ref); // From LocalizationMixin\n    // Implementation\n  }\n  \n  Widget _buildNewsList(AppLocalizations loc) {\n    // Private widget method\n  }\n}\n&#96;&#96;&#96;\n\n## Riverpod Provider Access in UI Layer\n\n**IMPORTANT**: Never use &#96;ref.watch()&#96; or &#96;ref.read()&#96; directly in UI layer files.\n\n### Rules\n\n1. **&#96;ref.watch()&#96; and &#96;ref.read()&#96;**: Must be encapsulated in state/event mixins\n   - Create methods in &#96;*_state.dart&#96; mixins for &#96;ref.watch()&#96; calls\n   - Create methods in &#96;*_event.dart&#96; mixins for &#96;ref.read()&#96; calls\n   - Call these mixin methods from the UI layer\n\n2. **&#96;ref.listen()&#96;**: Allowed in UI layer for side effects\n   - Use for showing snackbars, navigation callbacks, handling async results, etc.\n   - Must be called in the &#96;build&#96; method, typically at the beginning after getting localization\n\n### Listening to Async Results\n\nWhen listening to controller providers that return &#96;AsyncValue&#96;, use this pattern to handle errors and success states:\n\n**Pattern for Async Operations** (&#96;forgot_password_screen.dart&#96; lines 30‑49):\n&#96;&#96;&#96;dart\nref.listen&lt;AsyncValue&gt;(forgotPasswordControllerProvider, (prev, next) {\n  // Handle error state\n  if (next is AsyncError) {\n    if (!next.isRefreshing &amp;&amp; next.hasError) {\n      CustomSnackbar.show(\n        context,\n        CustomSnackbarMode.error,\n        next.error.toString(),\n      );\n    }\n  }\n  // Handle success state (transition from loading to data)\n  else if (next is AsyncData &amp;&amp; prev is AsyncLoading) {\n    if (context.mounted) {\n      CustomSnackbar.show(\n        context,\n        CustomSnackbarMode.success,\n        next.value?.message ?? '',\n      );\n      context.pop(); // Navigate back on success\n    }\n  }\n});\n&#96;&#96;&#96;\n\n**Key Points:**\n- **Error handling**: Check &#96;next is AsyncError&#96; and &#96;!next.isRefreshing&#96; to avoid showing errors during refresh\n- **Success handling**: Check &#96;next is AsyncData &amp;&amp; prev is AsyncLoading&#96; to detect successful completion\n- **Context safety**: Always check &#96;context.mounted&#96; before navigation or context-dependent operations\n- **Message extraction**: Use &#96;next.value?.message&#96; for API response messages, or provide fallback strings\n- **Navigation**: Use &#96;context.pop()&#96; or &#96;goToXxx(ref)&#96; from event mixins after successful operations\n\n**Additional Examples:**\n- &#96;help_desk_screen.dart&#96; lines 36‑54: Help desk form submission\n- &#96;account_screen.dart&#96; lines 36‑54: Logout operation\n- &#96;register_screen.dart&#96; lines 42‑60: Registration form submission\n\n### Correct Pattern\n\n&#96;&#96;&#96;dart\n// ✅ In *_state.dart mixin\nmixin class HomeState {\n  AsyncValue&lt;NewsListResponse?&gt; getNewsList(WidgetRef ref) =&gt;\n      ref.watch(getNewsListProvider);\n}\n\n// ✅ In UI layer\nclass HomeSubscreen extends ConsumerWidget with HomeState {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final newsList = getNewsList(ref); // Call mixin method\n    // ...\n  }\n}\n&#96;&#96;&#96;\n\n### Incorrect Pattern\n\n&#96;&#96;&#96;dart\n// ❌ Wrong: Direct ref.watch in UI layer\nclass HomeSubscreen extends ConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final newsList = ref.watch(getNewsListProvider); // Don't do this!\n    // ...\n  }\n}\n&#96;&#96;&#96;\n\n### Common Widgets\n\nReusable widgets should be placed in:\n- &#96;lib/src/common_widget/&#96; - App-wide reusable widgets\n- &#96;lib/src/feature/*/presentation/widget/&#96; - Feature-specific widgets\n\n## Navigation\n\nUse GoRouter for navigation via event mixins (never directly in UI layer):\n\n&#96;&#96;&#96;dart\n// ✅ In *_event.dart mixin\nmixin class HomeEvent {\n  void goToNewsDetail(WidgetRef ref, String newsId) {\n    ref.read(goRouterProvider).goNamed(\n      AppRoute.newsDetail.name,\n      pathParameters: {'currentIndex': '0'},\n      queryParameters: {'newsId': newsId},\n    );\n  }\n}\n\n// ✅ In UI layer - call mixin method\ngoToNewsDetail(ref, newsId);\n&#96;&#96;&#96;\n\nRoute definitions are in [app_router.dart](mdc:lib/src/routing/app_router.dart).\n\n## Loading States\n\nUse [AsyncValueWidget](mdc:lib/src/common_widget/async_value_widget.dart) for async data:\n\n&#96;&#96;&#96;dart\nAsyncValueWidget(\n  value: getNewsList(ref),\n  data: (newsList) =&gt; ListView(/* ... */),\n  loading: () =&gt; CircularProgressIndicator(),\n  error: (error, stack) =&gt; ErrorWidget(error),\n)\n&#96;&#96;&#96;\n\n### Shimmer Loading Placeholders\n\nFor loading placeholders in lists, grids, or tables, use [ShimmerLoadingItem](mdc:lib/src/common_widget/shimmer_loading_item.dart) instead of &#96;CircularProgressIndicator&#96;:\n\n**Pattern with AsyncValueWidget:**\n&#96;&#96;&#96;dart\nAsyncValueWidget(\n  value: getNewsList(ref),\n  customLoading: const ShimmerLoadingItem(), // Use shimmer for list loading\n  data: (newsList) =&gt; ListView(/* ... */),\n)\n&#96;&#96;&#96;\n\n**Pattern with AsyncValue.when() (for paginated lists):**\n&#96;&#96;&#96;dart\nListView.builder(\n  itemCount: totalResults ?? 0,\n  itemBuilder: (context, index) {\n    final res = getPageValue(page);\n    return res.when(\n      loading: () =&gt; const ShimmerLoadingItem(), // Shimmer for each item\n      error: (error, stackTrace) =&gt; /* handle error */,\n      data: (response) =&gt; /* build item */,\n    );\n  },\n)\n&#96;&#96;&#96;\n\n**Key Points:**\n- ✅ **Use for lists/grids**: &#96;ShimmerLoadingItem&#96; provides better UX for list-based loading\n- ✅ **Use in itemBuilder**: When using &#96;AsyncValue.when()&#96; inside &#96;ListView.builder&#96;, use shimmer for each loading item\n- ✅ **Consistent appearance**: Shimmer matches the layout structure of actual items\n- ✅ **Better than CircularProgressIndicator**: More appropriate for list-based content\n\n### Handling Empty Data and Errors\n\nWhen displaying lists or tables, show a single \"No Data\" message when:\n1. An error occurs during data loading\n2. The result is empty (no items)\n\n**Pattern for Paginated Lists (using AsyncValue.when()):**\n&#96;&#96;&#96;dart\nListView.builder(\n  itemCount: totalResults ?? 0,\n  itemBuilder: (context, index) {\n    final res = getPageValue(page);\n    return res.when(\n      // Show single \"No data\" message if page load failed (only on first item)\n      error: (error, stackTrace) =&gt; index == 0\n          ? Padding(\n              padding: EdgeInsets.all(16.w),\n              child: Text(\n                'No Data'.hardcoded,\n                style: AppTextTheme.regularSm,\n                textAlign: TextAlign.center,\n              ),\n            )\n          : const SizedBox.shrink(), // Hide for other items\n      // Show loading shimmer while page is loading\n      loading: () =&gt; const ShimmerLoadingItem(),\n      // Build item when data is available\n      data: (response) {\n        final items = extractItems(response);\n        if (items == null || items.isEmpty) {\n          return index == 0\n              ? Padding(\n                  padding: EdgeInsets.all(16.w),\n                  child: Text(\n                    'No Data'.hardcoded,\n                    style: AppTextTheme.regularSm,\n                    textAlign: TextAlign.center,\n                  ),\n                )\n              : const SizedBox.shrink();\n        }\n        // Build actual item\n        return ItemWidget(item: items[indexInPage]);\n      },\n    );\n  },\n)\n&#96;&#96;&#96;\n\n**Pattern for Simple Lists (using AsyncValueWidget):**\n&#96;&#96;&#96;dart\nAsyncValueWidget(\n  value: getDataList(ref),\n  data: (dataList) {\n    final items = dataList?.data ?? [];\n    // Show \"No Data\" if list is empty\n    if (items.isEmpty) {\n      return Center(\n        child: Text(\n          'No Data'.hardcoded,\n          style: AppTextTheme.regularSm,\n        ),\n      );\n    }\n    return ListView.builder(\n      itemCount: items.length,\n      itemBuilder: (context, index) =&gt; ItemWidget(item: items[index]),\n    );\n  },\n)\n&#96;&#96;&#96;\n\n**Pattern for Initial Loading Check:**\n&#96;&#96;&#96;dart\n// Check initial loading state before building list\nif (firstPageValue.isLoading ||\n    firstPageValue.isRefreshing ||\n    firstPageValue.isReloading) {\n  return const ShimmerLoadingItem(); // Or Center(child: CircularProgressIndicator())\n}\n\n// Check if data is empty\nfinal totalResults = extractTotal(firstPageValue.value);\nif (totalResults == 0) {\n  return Center(\n    child: Text(\n      'Data not found'.hardcoded,\n      style: AppTextTheme.regularSm,\n    ),\n  );\n}\n\n// Build list with data\nreturn ListView.builder(/* ... */);\n&#96;&#96;&#96;\n\n**Key Points:**\n- ✅ **Show once**: Use &#96;index == 0&#96; check to show \"No Data\" message only once in paginated lists\n- ✅ **Use &#96;SizedBox.shrink()&#96;**: Return empty widget for other indices when showing error/empty message\n- ✅ **Consistent messaging**: Use hardcoded strings like &#96;'No Data'.hardcoded&#96; or &#96;'Data not found'.hardcoded&#96;\n- ✅ **Center alignment**: Center the message for better visibility\n- ✅ **Check both error and empty**: Handle both error states and empty data states\n- ✅ **Padding**: Add padding around the message for better spacing\n\n## Pagination Display Patterns\n\nThis project uses **four standardized pagination layouts** to ensure every feature behaves consistently. All patterns share the same contract:\n\n### Common Contract for All Pagination Patterns\n\nEvery paginated view requires these parameters:\n\n- **&#96;firstPageValue&#96;**: &#96;AsyncValue&#96; for page 1, used for initial loading/empty state checks\n- **&#96;getPageValue&#96;**: Callback &#96;(int page) =&gt; AsyncValue&lt;Response&gt;&#96; that fetches a specific page\n- **&#96;extractTotal&#96;**: Function &#96;(Response?) =&gt; int?&#96; that extracts total item count from API response\n- **&#96;extractItems&#96;**: Function &#96;(Response?) =&gt; List&lt;Item&gt;?&#96; that extracts the data list from API response\n- **&#96;onRefresh&#96;**: Callback &#96;() async =&gt; void&#96; that invalidates providers (must be in event mixin, never in UI)\n- **&#96;buildItem&#96;**: Function &#96;(BuildContext, Item) =&gt; Widget&#96; that renders a single item widget\n\n### Pattern 1: Standard ListView (Vertical Scrolling List)\n\n**Use when:** Displaying a simple paginated list without categories (e.g., notifications, tasks, reports)\n\n**Reference:** &#96;notification_screen.dart&#96;, &#96;task_screen.dart&#96;\n\n**Structure:**\n&#96;&#96;&#96;dart\nclass NotificationScreen extends ConsumerWidget \n    with NotificationState, NotificationEvent, LocalizationMixin {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final loc = getLocalizations(ref);\n    return Scaffold(\n      appBar: AppBar(/* ... */),\n      body: Column(\n        children: [\n          gapH16,\n          Expanded(\n            child: Consumer(\n              builder: (context, consRef, child) {\n                return CategorizedTabBodyView&lt;NotificationResponse, NotificationData&gt;(\n                  categoryId: 0, // No category\n                  viewType: ViewType.listView,\n                  firstPageValue: getNotificationList(consRef, page: 1),\n                  getPageValue: (page) =&gt; getNotificationList(consRef, page: page),\n                  extractTotal: (data) =&gt; data?.data?.total,\n                  extractItems: (data) =&gt; data?.data?.notificationData,\n                  onRefresh: () async =&gt; onRefresh(consRef),\n                  buildItem: (context, item) =&gt; ItemNotificationWidget(/* ... */),\n                );\n              },\n            ),\n          ),\n        ],\n      ),\n    );\n  }\n}\n&#96;&#96;&#96;\n\n**Key Points:**\n- Use &#96;Column&#96; with &#96;gapH16&#96; + &#96;Expanded&#96; + &#96;Consumer&#96; wrapper\n- Set &#96;categoryId: 0&#96; when no categories exist\n- Set &#96;viewType: ViewType.listView&#96; (default)\n- &#96;CategorizedTabBodyView&#96; handles infinite scroll, shimmer, empty states automatically\n- Always use &#96;Consumer&#96; to properly scope Riverpod refs\n\n### Pattern 2: TableView With Fixed Header &amp; Filters\n\n**Use when:** Displaying tabular data with filterable columns and synchronized horizontal scrolling\n\n**Reference:** &#96;newsletter_screen.dart&#96;\n\n**Structure:**\n&#96;&#96;&#96;dart\nclass NewsletterScreen extends ConsumerWidget \n    with NewsletterState, NewsletterEvent, LocalizationMixin {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    return Scaffold(\n      appBar: AppBar(/* ... */),\n      body: LayoutBuilder(\n        builder: (context, constraints) {\n          // Calculate available height for table\n          final screenHeight = MediaQuery.sizeOf(context).height;\n          final appBarHeight = AppBar().preferredSize.height;\n          final statusBarHeight = MediaQuery.paddingOf(context).top;\n          final keyboardHeight = MediaQuery.viewInsetsOf(context).bottom;\n          final availableHeight = screenHeight - appBarHeight - statusBarHeight - keyboardHeight;\n          \n          final filterHeight = isFilterExpanded ? 450.h : 60.h;\n          final tableHeight = availableHeight - filterHeight - margins;\n          \n          return SingleChildScrollView(\n            child: Column(\n              children: [\n                _buildFilterAccordion(loc), // Collapsible filter form\n                gapH16,\n                SizedBox(\n                  height: tableHeight,\n                  child: _buildTableWithPagination(context, ref),\n                ),\n              ],\n            ),\n          );\n        },\n      ),\n    );\n  }\n  \n  Widget _buildTableWithPagination(BuildContext context, WidgetRef ref) {\n    final loc = getLocalizations(ref);\n    final firstPageValue = ref.watch(getNewsletterListProvider(page: 1));\n    \n    return NewsletterTableWithHeader(\n      firstPageValue: firstPageValue,\n      getPageValue: (page) =&gt; ref.watch(getNewsletterListProvider(page: page)),\n      extractTotal: (data) =&gt; data?.data?.total,\n      extractItems: (data) =&gt; data?.data?.data,\n      onRefresh: () async =&gt; ref.invalidate(getNewsletterListProvider(page: 1)),\n      onOpenAttachment: (pdfPath) =&gt; openAttachment(context, pdfPath),\n      loc: loc,\n    );\n  }\n}\n&#96;&#96;&#96;\n\n**Key Points:**\n- Use &#96;LayoutBuilder&#96; to calculate dynamic table height based on screen size and filter state\n- Wrap table in fixed-height &#96;SizedBox&#96; to prevent layout overflow\n- &#96;NewsletterTableWithHeader&#96; synchronizes horizontal scroll between header and body rows\n- Filter form should be collapsible (accordion pattern) to maximize table space\n- &#96;onRefresh&#96; only invalidates page 1 to preserve filter state\n- Always pass &#96;loc&#96; for localized column headers\n\n### Pattern 3: GridView With Category Tabs\n\n**Use when:** Displaying categorized content in a grid layout with tab navigation\n\n**Reference:** &#96;company_screen.dart&#96;, &#96;amenities_screen.dart&#96;\n\n**Structure:**\n&#96;&#96;&#96;dart\nclass CompanyScreen extends ConsumerWidget \n    with CompanyState, CompanyEvent, LocalizationMixin {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final loc = getLocalizations(ref);\n    return Scaffold(\n      appBar: AppBar(/* ... */),\n      body: Consumer(\n        builder: (context, consRef, child) {\n          return CategorizedTabView&lt;\n            CompanyCategoryListResponse,\n            CompanyCategoryData,\n            CompanyListResponse\n          &gt;(\n            categoriesValue: getCompanyCategoryList(consRef),\n            extractCategories: (data) =&gt; data?.companyCategoryData,\n            buildTabBarViewChild: (context, consRef, category) {\n              return CategorizedTabBodyView&lt;CompanyListResponse, CompanyData&gt;(\n                categoryId: category.id ?? 0,\n                viewType: ViewType.gridView,\n                firstPageValue: getCompanyListByCategory(\n                  consRef,\n                  page: 1,\n                  categoryId: category.id ?? 0,\n                ),\n                getPageValue: (page) =&gt; getCompanyListByCategory(\n                  consRef,\n                  page: page,\n                  categoryId: category.id ?? 0,\n                ),\n                extractTotal: (data) =&gt; data?.data?.total,\n                extractItems: (data) =&gt; data?.data?.companyData,\n                onRefresh: () async =&gt; onRefresh(consRef, category.id ?? 0),\n                buildItem: (context, item) =&gt; ItemSpotWidget(/* ... */),\n              );\n            },\n            onSearchSubmitted: (value) =&gt; onSearchSubmitted(consRef, value ?? ''),\n          );\n        },\n      ),\n    );\n  }\n}\n&#96;&#96;&#96;\n\n**Key Points:**\n- Use &#96;CategorizedTabView&#96; as top-level widget for tab management\n- &#96;categoriesValue&#96; fetches category list from state mixin\n- &#96;extractCategories&#96; maps API response to category list\n- &#96;buildTabBarViewChild&#96; returns &#96;CategorizedTabBodyView&#96; for each tab\n- Each tab has **isolated pagination** scoped to &#96;category.id&#96;\n- Set &#96;viewType: ViewType.gridView&#96; for 2-column grid layout\n- &#96;onRefresh&#96; invalidates both category list and active category's data\n- Optional &#96;onSearchSubmitted&#96; for search functionality across all tabs\n\n### Pattern 4: GridView Without Tabs (Simple Grid)\n\n**Use when:** Displaying grid content without categories (e.g., embed links, others)\n\n**Reference:** &#96;embed_screen.dart&#96;\n\n**Structure:**\n&#96;&#96;&#96;dart\nclass EmbedScreen extends ConsumerWidget \n    with EmbedState, EmbedEvent, LocalizationMixin {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final loc = getLocalizations(ref);\n    return Scaffold(\n      appBar: AppBar(/* ... */),\n      body: Column(\n        children: [\n          gapH16,\n          Expanded(\n            child: Consumer(\n              builder: (context, consRef, child) {\n                return CategorizedTabBodyView&lt;EmbedListResponse, EmbedData&gt;(\n                  categoryId: 0, // No category\n                  viewType: ViewType.gridView,\n                  itemAspectRatio: 1.1, // Optional: control tile proportions\n                  firstPageValue: getEmbedList(consRef, page: 1),\n                  getPageValue: (page) =&gt; getEmbedList(consRef, page: page),\n                  extractTotal: (data) =&gt; data?.data?.total,\n                  extractItems: (data) =&gt; data?.data?.data,\n                  onRefresh: () async =&gt; onRefresh(consRef),\n                  buildItem: (context, item) {\n                    final localeNumber = getLocaleToNumber(ref);\n                    final title = localeNumber == 1 ? item.titleId : item.titleEn;\n                    return ItemEmbedWidget(\n                      imageUrl: item.image ?? '',\n                      title: title ?? '',\n                      onTap: () =&gt; launchEmbedUrl(context, item.link, title ?? ''),\n                    );\n                  },\n                );\n              },\n            ),\n          ),\n        ],\n      ),\n    );\n  }\n}\n&#96;&#96;&#96;\n\n**Key Points:**\n- Similar to Pattern 1 (ListView) but with &#96;viewType: ViewType.gridView&#96;\n- Set &#96;categoryId: 0&#96; when no categories exist\n- Use &#96;itemAspectRatio&#96; to control grid tile width/height ratio (default is calculated automatically)\n- Locale-specific content (title/description) handled in &#96;buildItem&#96; via &#96;LocalizationMixin&#96;\n- Grid automatically displays 2 columns with responsive spacing\n\n### Pattern Selection Guide\n\n| Pattern | Use Case | Has Categories? | Layout | Example Features |\n|---------|----------|----------------|--------|------------------|\n| **Pattern 1: ListView** | Simple vertical list | No | Vertical scroll | Notifications, Tasks |\n| **Pattern 2: TableView** | Tabular data with filters | No | Table with fixed header | Newsletter, Reports |\n| **Pattern 3: GridView + Tabs** | Categorized grid content | Yes | Grid with tabs | Company, Amenities |\n| **Pattern 4: GridView** | Simple grid content | No | Grid without tabs | Embed/Others |\n\n### Benefits of These Patterns\n\n- ✅ **Consistent UX**: All features use the same pagination, loading, and error handling\n- ✅ **Automatic infinite scroll**: &#96;CategorizedTabBodyView&#96; handles pagination automatically\n- ✅ **Built-in shimmer states**: Loading placeholders shown during data fetch\n- ✅ **Empty/error handling**: Centralized \"No Data\" and error messages\n- ✅ **Pull-to-refresh**: Integrated refresh indicator (when &#96;onRefresh&#96; provided)\n- ✅ **Scroll position preservation**: PageStorageKey maintains scroll when switching tabs\n\n### Fetching Paginated Data From the API\n\nAll paginated widgets rely on repository providers that follow a standardized contract. This ensures consistency across features and proper integration with the pagination UI patterns.\n\n#### Repository Provider Structure\n\n**1. Provider Declaration**\n\nDeclare a &#96;@riverpod&#96; function that accepts a &#96;page&#96; parameter plus any filters (category ID, search keyword, etc.):\n\n&#96;&#96;&#96;dart\n@riverpod\nFuture&lt;NotificationResponse?&gt; getNotificationList(\n  Ref ref, {\n  required int page,\n}) async {\n  try {\n    final dio = ref.watch(dioConfigProvider);\n    final userId = ref.watch(authRepositoryProvider).currentUser?.userId;\n    \n    // Early return if required data is missing\n    if (userId == null) return null;\n\n    final response = await dio.post(\n      '/api/v1/getnotificationlist',\n      data: {\n        'user_id': userId,\n        'limit': Constants.limit,\n        'language_id': ref.watch(localeProviderToNumber),\n        'page': page,\n      },\n      cancelToken: ref.cancelToken(),\n    );\n    \n    return NotificationResponse.fromJson(response.data);\n  } on DioException catch (error) {\n    throw onDioError(error);\n  } catch (e) {\n    rethrow;\n  }\n}\n&#96;&#96;&#96;\n\n**2. Required Request Payload Fields**\n\nEvery paginated API call must include:\n\n- **&#96;limit&#96;**: Use &#96;Constants.limit&#96; (typically 10 or 20) for consistency across all features\n- **&#96;page&#96;**: Forward the method parameter directly (1-indexed)\n- **&#96;language_id&#96;**: Read from &#96;ref.watch(localeProviderToNumber)&#96; for localized responses\n- **Additional filters**: Read from &#96;StateProvider&#96;s (e.g., &#96;categoryId&#96;, &#96;search&#96;, &#96;year&#96;, &#96;month&#96;)\n\n**3. Cancel Token Management**\n\nAlways use &#96;ref.cancelToken()&#96; to automatically cancel in-flight requests when:\n- Widget is disposed\n- User navigates away\n- New request is triggered\n\n&#96;&#96;&#96;dart\ncancelToken: ref.cancelToken(), // Automatic cleanup\n&#96;&#96;&#96;\n\n**4. Error Handling Pattern**\n\nWrap all network calls in try-catch with proper error conversion:\n\n&#96;&#96;&#96;dart\ntry {\n  // API call\n} on DioException catch (error) {\n  throw onDioError(error); // Convert to user-friendly message\n} catch (e) {\n  rethrow; // Preserve unknown errors\n}\n&#96;&#96;&#96;\n\n**Key Points:**\n- Keep repositories thin—no UI logic, no logging side effects\n- Return &#96;null&#96; for missing required data (e.g., &#96;userId == null&#96;)\n- Use &#96;onDioError()&#96; helper to convert &#96;DioException&#96; to readable error messages\n- Never catch errors silently—always rethrow or convert\n\n#### Filter State Management\n\n**5. Form-Driven Filter Submission Pattern**\n\nWhen filters should only apply after user taps a submit button (not on every dropdown change):\n\n**Step 1: Create Local StateProviders** (in screen file)\n&#96;&#96;&#96;dart\n// Local state for form selections (not used by repository yet)\nfinal localCategoryIdProvider = StateProvider.autoDispose&lt;int&gt;((ref) =&gt; 0);\nfinal localYearProvider = StateProvider.autoDispose&lt;int&gt;((ref) =&gt; 0);\nfinal localMonthProvider = StateProvider.autoDispose&lt;int&gt;((ref) =&gt; 0);\n&#96;&#96;&#96;\n\n**Step 2: Create Global StateProviders** (in controller file)\n&#96;&#96;&#96;dart\n// Global state used by repository\nfinal newsletterCategoryIdProvider = StateProvider.autoDispose&lt;int&gt;((ref) =&gt; 0);\nfinal newsletterYearProvider = StateProvider.autoDispose&lt;int&gt;((ref) =&gt; 0);\nfinal newsletterMonthProvider = StateProvider.autoDispose&lt;int&gt;((ref) =&gt; 0);\nfinal newsletterKeywordProvider = StateProvider.autoDispose&lt;String&gt;((ref) =&gt; '');\n&#96;&#96;&#96;\n\n**Step 3: Repository Reads Global Providers**\n&#96;&#96;&#96;dart\n@riverpod\nFuture&lt;NewsletterResponse?&gt; getNewsletterList(\n  Ref ref, {\n  required int page,\n}) async {\n  final dio = ref.watch(dioConfigProvider);\n  \n  // Read from global providers (not local ones)\n  final categoryId = ref.watch(newsletterCategoryIdProvider);\n  final search = ref.watch(newsletterKeywordProvider);\n  final month = ref.watch(newsletterMonthProvider);\n  final year = ref.watch(newsletterYearProvider);\n  \n  final response = await dio.post(\n    '/api/v1/getnewsletterlist',\n    data: {\n      'limit': Constants.limit,\n      'page': page,\n      'category_id': categoryId,\n      'search': search,\n      if (month != 0) 'month': month, // Conditional fields\n      if (year != 0) 'year': year,\n    },\n    cancelToken: ref.cancelToken(),\n  );\n  \n  return NewsletterResponse.fromJson(response.data);\n}\n&#96;&#96;&#96;\n\n**Step 4: Event Mixin Copies Local → Global on Submit**\n\n&#96;&#96;&#96;dart\nmixin class NewsletterEvent {\n  static const String keyKeyword = 'keyword';\n\n  Future&lt;void&gt; onSubmitSearchNewsletter(\n    WidgetRef ref,\n    GlobalKey&lt;FormBuilderState&gt; formKey,\n  ) async {\n    // 1. Unfocus keyboard\n    FocusManager.instance.primaryFocus?.unfocus();\n\n    // 2. Validate form\n    if (formKey.currentState?.saveAndValidate() ?? false) {\n      // 3. Extract form values\n      final keyword = formKey.currentState!.value[keyKeyword] as String? ?? '';\n\n      // 4. Copy local state → global state (used by repository)\n      ref.read(newsletterKeywordProvider.notifier).state = keyword;\n      ref.read(newsletterCategoryIdProvider.notifier).state =\n          ref.read(localCategoryIdProvider);\n      ref.read(newsletterYearProvider.notifier).state =\n          ref.read(localYearProvider);\n      ref.read(newsletterMonthProvider.notifier).state =\n          ref.read(localMonthProvider);\n\n      // 5. Invalidate page 1 to trigger new API call with updated filters\n      ref.invalidate(getNewsletterListProvider(page: 1));\n    }\n  }\n}\n&#96;&#96;&#96;\n\n**Why This Pattern?**\n\nThis two-tier state approach ensures predictable filter behavior:\n\n- ✅ **No premature API calls**: Users can adjust dropdowns/dates without triggering requests\n- ✅ **Explicit submission**: API only fires when user taps \"Search\" button\n- ✅ **State isolation**: Local providers hold \"draft\" values, global providers hold \"committed\" values\n- ✅ **Repository simplicity**: Repository only reads global providers, never UI state\n- ✅ **Consistent UX**: All filterable features (newsletter, reports, etc.) behave the same way\n\n**When to Use:**\n- ✅ Use this pattern when filters have a submit button\n- ❌ Don't use for instant search (where each keystroke triggers API)\n- ❌ Don't use for category tabs (where tab change should immediately load data)\n\n## Item Widgets &amp; Display Lists\n\nEvery scrolling surface (paginated or not) must separate the **collection widget** from the **single-item widget** for maintainability and reusability.\n\n### Widget Separation Pattern\n\n**Collection Widget** (Screen/Subscreen)\n- Sets up the overall layout (AppBar, Scaffold, Column structure)\n- Fetches data via state mixins (&#96;getNotificationList&#96;, &#96;getTaskList&#96;, etc.)\n- Decides view type: &#96;ListView&#96;, &#96;GridView&#96;, or table\n- Handles pagination setup (&#96;CategorizedTabBodyView&#96; or &#96;AsyncValueWidget&#96;)\n- Manages pull-to-refresh and empty/error states\n\n**Item Widget** (Reusable Component)\n- Renders a single data item\n- Stateless and purely presentational\n- Filename starts with &#96;item_&#96; prefix\n- Lives in &#96;feature/*/presentation/widget/&#96; folder\n\n### Naming Conventions\n\n**Files** (snake_case):\n- &#96;item_task_widget.dart&#96;\n- &#96;item_notification_widget.dart&#96;\n- &#96;item_embed_widget.dart&#96;\n- &#96;item_spot_widget.dart&#96;\n- &#96;item_news_widget.dart&#96;\n- &#96;item_event_widget.dart&#96;\n- &#96;item_report_widget.dart&#96;\n\n**Classes** (PascalCase):\n- &#96;ItemTaskWidget&#96;\n- &#96;ItemNotificationWidget&#96;\n- &#96;ItemEmbedWidget&#96;\n- &#96;ItemSpotWidget&#96;\n- &#96;ItemNewsWidget&#96;\n- &#96;ItemEventWidget&#96;\n- &#96;ItemReportWidget&#96;\n\n**Domain Models** (for list items):\n- Files: &#96;item_faq.dart&#96; (not &#96;faq_item.dart&#96;)\n- Classes: &#96;ItemFaq&#96; (not &#96;FaqItem&#96;)\n\n**Imports:**\n&#96;&#96;&#96;dart\nimport 'package:{{project_name}}/src/feature/task/presentation/widget/item_task_widget.dart';\n&#96;&#96;&#96;\n\n### Building Item Widgets\n\nFollow these principles when creating item widgets:\n\n**1. Always Stateless**\n&#96;&#96;&#96;dart\nclass ItemTaskWidget extends StatelessWidget {\n  const ItemTaskWidget({super.key, required this.task, this.onTap});\n  \n  final TaskData task;\n  final VoidCallback? onTap;\n  \n  @override\n  Widget build(BuildContext context) {\n    // Render logic\n  }\n}\n&#96;&#96;&#96;\n\n**2. Accept Domain Model + Callbacks**\n- Primary data: Domain model (e.g., &#96;TaskData task&#96;, &#96;NotificationData notification&#96;)\n- Interaction: Nullable &#96;VoidCallback? onTap&#96; for navigation\n- Avoid passing &#96;WidgetRef&#96; or state providers—keep it pure\n\n**3. Handle Formatting Locally**\n&#96;&#96;&#96;dart\n@override\nWidget build(BuildContext context) {\n  // Format dates/numbers inside the widget\n  final formattedDate = CommonUtils.formatDateWithLocale(\n    task.date,\n    dateFormat: 'dd MMMM yyyy',\n  );\n  \n  return Container(/* ... */);\n}\n&#96;&#96;&#96;\n\n**4. Use Theme Constants**\n&#96;&#96;&#96;dart\nText(\n  task.number ?? '-',\n  style: AppTextTheme.semiBoldBase.copyWith(\n    color: AppColorTheme.blackRock500,\n  ),\n)\n&#96;&#96;&#96;\n\n**5. Encapsulate Repeated UI Elements**\n\nIf the item has repeated chips/badges/tags, create private helper widgets/classes:\n\n&#96;&#96;&#96;dart\nclass ItemTaskWidget extends StatelessWidget {\n  // Main widget code\n  \n  Widget _buildInOutChip(String? value) {\n    if (value == null || value.isEmpty) return const SizedBox.shrink();\n    return Container(/* chip UI */);\n  }\n  \n  Color _statusChipColor(String? value) {\n    // Color logic\n  }\n}\n\n// Private helper class for complex chips\nclass _StatusChip extends StatelessWidget {\n  const _StatusChip({\n    required this.label,\n    required this.backgroundColor,\n    required this.textColor,\n  });\n  \n  final String label;\n  final Color backgroundColor;\n  final Color textColor;\n  \n  @override\n  Widget build(BuildContext context) {\n    return Container(/* ... */);\n  }\n}\n&#96;&#96;&#96;\n\n### Wiring Item Widgets to Collections\n\n**For Paginated Lists:**\n&#96;&#96;&#96;dart\nCategorizedTabBodyView&lt;TaskResponse, TaskData&gt;(\n  // ... pagination setup\n  buildItem: (context, item) =&gt; ItemTaskWidget(\n    task: item,\n    onTap: () =&gt; goToTaskDetail(ref, item.id),\n  ),\n)\n&#96;&#96;&#96;\n\n**For Non-Paginated Lists:**\n&#96;&#96;&#96;dart\nAsyncValueWidget(\n  value: getNewsList(ref),\n  data: (newsList) {\n    final items = newsList?.data ?? [];\n    return ListView.separated(\n      itemCount: items.length,\n      separatorBuilder: (context, index) =&gt; gapH8,\n      itemBuilder: (context, index) =&gt; ItemNewsWidget(\n        imageUrl: items[index].image ?? '',\n        categoryName: items[index].categoryName ?? '',\n        headline: items[index].headline ?? '',\n        date: items[index].date,\n        onTap: () =&gt; goToNewsDetail(ref, items[index].id),\n      ),\n    );\n  },\n)\n&#96;&#96;&#96;\n\n### Reusability Benefits\n\n- ✅ **Consistent UI**: Same item widget used in multiple places (dashboard preview + full list screen)\n- ✅ **Easy testing**: Stateless widgets are easier to test in isolation\n- ✅ **Maintainable**: Changes to item design only need updating in one file\n- ✅ **Clear separation**: Collection handles data/pagination, item handles presentation\n- ✅ **Type-safe**: Domain model ensures compile-time safety\n\n### Example Structure\n\n&#96;&#96;&#96;\nlib/src/feature/task/\n├── data/\n│   └── task_repository.dart\n├── domain/\n│   └── task_response.dart\n└── presentation/\n    ├── task_screen.dart              ← Collection widget\n    ├── controller/\n    │   ├── task_event.dart\n    │   └── task_state.dart\n    └── widget/\n        └── item_task_widget.dart     ← Item widget\n&#96;&#96;&#96;\n\n## Images\n\n- **Network images**: Use &#96;CachedNetworkImage&#96; from &#96;cached_network_image&#96; package\n- **Assets**: Use &#96;Image.asset()&#96; with constants from [assets_constant.dart](mdc:lib/src/constant/assets_constant.dart)\n- **SVG**: Use &#96;SvgPicture.asset()&#96; from &#96;flutter_svg&#96;\n\nAlways provide placeholder and error widgets for network images.\n\n### Image Picker Pattern\n\nFor features that allow users to pick/capture images (e.g., profile pictures):\n\n1. **Use &#96;image_picker&#96; package**: Latest version from pub.dev\n2. **Show bottom sheet with options**: Gallery or Camera (&#96;info_personal_event.dart&#96; lines 22‑68)\n3. **Handle Android MainActivity destruction**: Call &#96;retrieveLostData()&#96; in &#96;initState()&#96; or before showing picker (only on Android with &#96;Platform.isAndroid&#96; checks)\n4. **Store image path in StateProvider**: Create &#96;StateProvider.autoDispose&lt;String?&gt;&#96; in controller for the selected image path\n5. **Display with conditional logic**: Show selected file, cached network image, or placeholder icon\n\n**Example Event Mixin Pattern** (&#96;info_personal_event.dart&#96; lines 38‑100):\n&#96;&#96;&#96;dart\nFuture&lt;void&gt; pickImage(BuildContext context, WidgetRef ref) async {\n  final ImagePicker picker = ImagePicker();\n\n  // Handle Android lost data (MainActivity destruction recovery)\n  // This is a secondary check - primary check happens when screen is mounted\n  // NOTE: retrieveLostData() is only implemented on Android, not on iOS or web\n  if (Platform.isAndroid) {\n    try {\n      final LostDataResponse lostData = await picker.retrieveLostData();\n      if (lostData.isEmpty == false) {\n        final List&lt;XFile&gt;? files = lostData.files;\n        if (files != null &amp;&amp; files.isNotEmpty) {\n          // Lost data found - restore the selected image\n          setProfileImagePath(ref, files.first.path);\n          return;\n        } else if (lostData.exception != null) {\n          // Handle exception from lost data\n          CommonUtils.printAndRecordLog(\n            'Lost image picker exception: ${lostData.exception}',\n            '',\n          );\n        }\n      }\n    } catch (e, st) {\n      // Handle any errors from retrieveLostData\n      CommonUtils.printAndRecordLog(\n        'Error retrieving lost image data: $e',\n        st.toString(),\n      );\n    }\n  }\n\n  if (!context.mounted) return;\n\n  // Show bottom sheet for image source selection\n  final result = await showModalBottomSheet&lt;ImageSource&gt;(\n    context: context,\n    builder: (context) =&gt; SafeArea(\n      child: Column(\n        mainAxisSize: MainAxisSize.min,\n        children: [\n          ListTile(\n            leading: const Icon(Icons.photo_library),\n            title: const Text('Pick from Gallery'),\n            onTap: () =&gt; Navigator.pop(context, ImageSource.gallery),\n          ),\n          ListTile(\n            leading: const Icon(Icons.camera_alt),\n            title: const Text('Take Photo'),\n            onTap: () =&gt; Navigator.pop(context, ImageSource.camera),\n          ),\n        ],\n      ),\n    ),\n  );\n\n  // Pick image and store path in StateProvider\n  if (result != null &amp;&amp; context.mounted) {\n    final XFile? image = await picker.pickImage(source: result);\n    if (image != null) {\n      setProfileImagePath(ref, image.path);\n    }\n  }\n}\n&#96;&#96;&#96;\n\n**Key Points:**\n- ✅ **Android lost data handling**: Always call &#96;retrieveLostData()&#96; on Android to recover from MainActivity destruction\n- ✅ **Platform check**: Use &#96;Platform.isAndroid&#96; before calling &#96;retrieveLostData()&#96; (iOS/web don't support it)\n- ✅ **Error handling**: Wrap &#96;retrieveLostData()&#96; in try-catch and log errors\n- ✅ **Context safety**: Check &#96;context.mounted&#96; before navigation-dependent operations\n- ✅ **StateProvider storage**: Store file path in &#96;StateProvider.autoDispose&lt;String?&gt;&#96; via event mixin setter\n- ✅ **Bottom sheet pattern**: Use &#96;showModalBottomSheet&#96; with &#96;SafeArea&#96; for image source selection\n\n**Example UI Pattern** (&#96;info_personal_screen.dart&#96; lines 110‑168):\n&#96;&#96;&#96;dart\nConsumer(\n  builder: (context, consRef, child) {\n    final profileImagePath = consRef.watch(profileImagePathProvider);\n    \n    return GestureDetector(\n      onTap: () =&gt; pickImage(context, consRef),\n      child: Stack(\n        children: [\n          Container(\n            width: 100.w,\n            height: 100.w,\n            decoration: BoxDecoration(\n              shape: BoxShape.circle,\n              border: Border.all(color: AppColorTheme.blackRock100, width: 2),\n            ),\n            child: ClipOval(\n              child: profileImagePath != null\n                  ? Image.file(File(profileImagePath), fit: BoxFit.cover)\n                  : !CommonUtils.isEmpty(originalImageUrl)\n                      ? CachedNetworkImage(\n                          imageUrl: originalImageUrl,\n                          fit: BoxFit.cover,\n                          placeholder: (context, url) =&gt; const CircularProgressIndicator(),\n                          errorWidget: (context, url, error) =&gt; Image.asset(AssetsConstant.avatar),\n                        )\n                      : Icon(Icons.person, size: 50.w, color: AppColorTheme.blackRock300),\n            ),\n          ),\n          Positioned(\n            bottom: 0,\n            right: 0,\n            child: Container(\n              padding: EdgeInsets.all(4.w),\n              decoration: BoxDecoration(\n                color: AppColorTheme.primary500,\n                shape: BoxShape.circle,\n              ),\n              child: Icon(Icons.camera_alt, size: 20.w, color: AppColorTheme.white),\n            ),\n          ),\n        ],\n      ),\n    );\n  },\n)\n&#96;&#96;&#96;\n\n**Key Points:**\n- ✅ **Wrap in Consumer**: Rebuild when &#96;profileImagePathProvider&#96; changes\n- ✅ **Priority order**: Show selected file → original from API → placeholder icon\n- ✅ **Use &#96;Image.file()&#96;**: Display local file using &#96;File(imagePath)&#96; when path is available\n- ✅ **Use &#96;CachedNetworkImage&#96;**: Display original image from API URL when no local file\n- ✅ **Error handling**: Provide fallback placeholder for network image errors\n- ✅ **Visual feedback**: Add camera icon overlay to indicate image is tappable\n\n**File Upload Integration:**\n- The selected file path is stored in &#96;StateProvider&#96; and passed to controller on form submission\n- Controller conditionally uploads file using &#96;FormData&#96; with &#96;MultipartFile&#96; (see [File Upload Pattern](mdc:.cursor/rules/riverpod-patterns.mdc) in riverpod-patterns.mdc)\n\n**iOS Permissions** (&#96;ios/Runner/Info.plist&#96;):\n&#96;&#96;&#96;xml\n&lt;key&gt;NSPhotoLibraryUsageDescription&lt;/key&gt;\n&lt;string&gt;We need access to your photo library to update your profile picture&lt;/string&gt;\n&lt;key&gt;NSCameraUsageDescription&lt;/key&gt;\n&lt;string&gt;We need access to your camera to take a profile picture&lt;/string&gt;\n&#96;&#96;&#96;\n\n## Forms\n\nUse &#96;flutter_form_builder&#96; for form handling:\n- Custom form fields in &#96;lib/src/common_widget/form/&#96;\n- Validation with &#96;form_builder_validators&#96;\n- Localized error messages\n\n### Custom Form Fields\n\n- Always use the shared form widgets instead of creating ad‑hoc fields:\n  - &#96;CustomDropdownFormField&#96; for any dropdown (&#96;register_screen.dart&#96; lines 155‑170).\n  - &#96;CustomTextFormField&#96; for text/textarea inputs (&#96;help_desk_screen.dart&#96; lines 96‑137).\n  - &#96;CustomDatePickerField&#96; for date selection (&#96;register_screen.dart&#96; lines 195‑205).\n- These widgets already apply spacing, theming, and validation styles. Pass localization titles/hints (e.g. &#96;*${loc.category}&#96;) and surface validation errors via their &#96;errorValidation&#96; parameter for dropdowns/date pickers or built‑in validators for text fields.\n\n### State Management for Form Inputs\n\n- When a form needs to reuse dropdown selections, date picker values, or other form inputs (e.g. submit to repository), declare &#96;StateProvider.autoDispose&#96; fields in the feature controller file. Examples:\n  - &#96;help_desk_controller.dart&#96; lines 6‑17 create &#96;helpDeskCategoryProvider&#96;, &#96;helpDeskSubCategoryProvider&#96;, &#96;helpDeskShowErrorsProvider&#96;.\n  - &#96;register_controller.dart&#96; line 8 creates &#96;dateOfBirthProvider&#96; for date selection.\n- Read these providers inside repositories instead of passing raw values through every method. Example: &#96;help_desk_repository.dart&#96; lines 19‑20 read the selected categories before calling &#96;/api/v1/sendfeedback&#96;.\n- Expose helper getters in the feature &#96;*_state.dart&#96; mixin and setters in the feature &#96;*_event.dart&#96; so UI widgets can update the providers without direct &#96;ref.watch&#96;. Example: &#96;register_state.dart&#96; line 14 exposes &#96;getDateOfBirth()&#96; and &#96;register_event.dart&#96; line 90 exposes &#96;setDateOfBirth()&#96;.\n\n### Form-Driven Filter Submission Pattern\n\nWhen filters should only apply after user taps a submit button (not on every dropdown change), use a **two-tier StateProvider pattern**:\n\n**1. Local StateProviders** (in screen/widget file):\n- Defined in the screen or dialog widget file (e.g., &#96;newsletter_screen.dart&#96;, &#96;task_filter_dialog.dart&#96;)\n- Used for immediate UI updates when dropdowns change\n- **NOT** used by repository for API calls\n- Example: &#96;localCategoryIdProvider&#96;, &#96;localTaskSourceProvider&#96;\n\n**2. Global StateProviders** (in controller file):\n- Defined in the feature controller file (e.g., &#96;newsletter_controller.dart&#96;, &#96;task_controller.dart&#96;)\n- Used by repository for API filtering\n- Only updated when submit button is pressed\n- Example: &#96;newsletterCategoryIdProvider&#96;, &#96;taskSourceProvider&#96;\n\n**Pattern Implementation:**\n\n**Step 1: Define Local Providers** (in screen/widget file):\n&#96;&#96;&#96;dart\n// Local StateProviders for form field selections (stored locally, not in global providers)\n// These values are only updated when the search button is pressed\n// They are used to immediately update the UI when dropdowns change\nfinal localCategoryIdProvider = StateProvider.autoDispose&lt;int&gt;((ref) =&gt; 0);\nfinal localTaskSourceProvider = StateProvider.autoDispose&lt;String?&gt;((ref) =&gt; null);\n&#96;&#96;&#96;\n\n**Step 2: Define Global Providers** (in controller file):\n&#96;&#96;&#96;dart\n// Global StateProviders used by repository for API filtering\nfinal newsletterCategoryIdProvider = StateProvider.autoDispose&lt;int&gt;((ref) =&gt; 0);\nfinal taskSourceProvider = StateProvider.autoDispose&lt;String?&gt;((ref) =&gt; null);\n&#96;&#96;&#96;\n\n**Step 3: Add Local Provider Getters/Setters** (in state/event mixins):\n&#96;&#96;&#96;dart\n// In *_state.dart mixin\nmixin class TaskState {\n  String? getLocalSelectedTaskSource(WidgetRef ref) =&gt;\n      ref.watch(localTaskSourceProvider);\n}\n\n// In *_event.dart mixin\nmixin class TaskEvent {\n  void setLocalSelectedTaskSource(WidgetRef ref, String? source) {\n    ref.read(localTaskSourceProvider.notifier).state = source;\n  }\n}\n&#96;&#96;&#96;\n\n**Step 4: Use Local Providers in UI** (dropdowns update local providers):\n&#96;&#96;&#96;dart\nCustomDropdownFormField&lt;ItemDropdown&gt;(\n  title: 'Source'.hardcoded,\n  hintText: 'Select source'.hardcoded,\n  items: items,\n  valueId: getLocalSelectedTaskSource(consRef), // Read from local provider\n  onChanged: (item) {\n    setLocalSelectedTaskSource(consRef, item?.id); // Update local provider immediately\n  },\n)\n&#96;&#96;&#96;\n\n**Step 5: Submit Handler** (copy local → global, read textfield from formKey):\n&#96;&#96;&#96;dart\nFuture&lt;void&gt; submitFilter(\n  WidgetRef ref,\n  GlobalKey&lt;FormBuilderState&gt; formKey,\n) async {\n  FocusManager.instance.primaryFocus?.unfocus();\n  formKey.currentState?.save();\n  final values = formKey.currentState!.value;\n  \n  // Read textfield value from formKey\n  final keywordValue = values[TaskEvent.keyKeyword] as String?;\n  \n  // Read dropdown values from local providers\n  final taskState = TaskState();\n  final source = taskState.getLocalSelectedTaskSource(ref);\n  final departmentId = taskState.getLocalSelectedTaskDepartmentId(ref);\n  \n  // Copy local providers to global providers (used by repository)\n  ref.read(taskKeywordProvider.notifier).state = keywordValue;\n  ref.read(taskSourceProvider.notifier).state = source;\n  ref.read(taskDepartmentIdProvider.notifier).state = departmentId;\n  \n  // Invalidate to trigger new API call with filters\n  ref.invalidate(getTaskListProvider(page: 1));\n}\n&#96;&#96;&#96;\n\n**Key Points:**\n- ✅ **Local providers**: Update immediately on dropdown change for UI feedback\n- ✅ **Global providers**: Only updated on submit, used by repository for API calls\n- ✅ **TextField values**: Read from &#96;formKey.currentState!.value&#96; on submit\n- ✅ **Dropdown values**: Read from local providers on submit, then copy to global\n- ✅ **Separation of concerns**: UI state (local) vs API state (global)\n- ✅ **No premature API calls**: Filters only apply when user explicitly submits\n\n**Reference Examples:**\n- &#96;newsletter_screen.dart&#96; lines 25‑27: Local providers definition\n- &#96;newsletter_event.dart&#96; lines 15‑25: Local provider setters\n- &#96;newsletter_event.dart&#96; lines 27‑48: Submit handler pattern\n- &#96;task_filter_dialog.dart&#96;: Complete implementation example\n\n### Pre-filling Forms with API Data\n\nWhen a form needs to be pre-filled with data from an API:\n\n1. **Wrap form in &#96;AsyncValueWidget&#96;**: Load the data first, then render the form once data is available (&#96;info_personal_screen.dart&#96; lines 87‑292).\n2. **Set &#96;initialValue&#96; on FormBuilder fields**: Use the fetched data to pre-fill text fields (&#96;info_personal_screen.dart&#96; lines 182‑189, 192‑202, 245‑255, 258‑267).\n3. **Pre-fill StateProviders in repository**: For dropdown/date picker fields managed by &#96;StateProvider&#96;, set their values **in the repository** immediately after parsing the API response (&#96;info_personal_repository.dart&#96; lines 29‑31). This ensures the state is ready before the UI renders. Make sure StateProviders is auto disposed\n4. **Access values via form key in events**: Read FormBuilder field values using &#96;formKey.currentState!.value['keyName']&#96; in event mixins when submitting (&#96;info_personal_event.dart&#96; lines 70‑73, 96‑110).\n\n**Example Repository Pattern:**\n&#96;&#96;&#96;dart\n@riverpod\nFuture&lt;CustomerDetailResponse?&gt; getCustomerDetail(Ref ref) async {\n  // ... API call\n  final result = CustomerDetailResponse.fromJson(response.data);\n  \n  // ✅ Pre-fill StateProviders immediately after parsing\n  ref.watch(genderProvider.notifier).state = result.data?.customer?.gender;\n  ref.watch(dateOfBirthProvider.notifier).state = result.data?.customer?.dateOfBirth;\n  \n  return result;\n}\n&#96;&#96;&#96;\n\n**Example UI Pattern:**\n&#96;&#96;&#96;dart\nAsyncValueWidget(\n  value: getCustomerDetail(ref), // Fetch data first\n  data: (customerDetail) {\n    final user = customerDetail?.data?.user;\n    return FormBuilder(\n      key: _formKey,\n      child: Column(\n        children: [\n          CustomTextFormField(\n            initialValue: user?.fullname, // Pre-fill from API\n            name: keyFullName,\n            // ...\n          ),\n          Consumer(\n            builder: (context, consRef, child) {\n              return CustomDropdownFormField(\n                valueId: getGender(consRef), // Already set in repository\n                // ...\n              );\n            },\n          ),\n        ],\n      ),\n    );\n  },\n)\n&#96;&#96;&#96;\n\n### Rebuilding Form Widgets\n\n- Wrap dropdowns, date pickers, and buttons that depend on provider state in a &#96;Consumer&#96; (or use a &#96;ConsumerWidget&#96;) so they rebuild correctly and only rebuild necessary part when the providers change. See:\n  - &#96;register_screen.dart&#96; lines 155‑170 for dropdown rebuild.\n  - &#96;register_screen.dart&#96; lines 195‑205 for date picker rebuild with state management.\n  - &#96;register_screen.dart&#96; lines 228‑247 for buttons that reflect controller loading state.\n  - &#96;info_personal_screen.dart&#96; lines 205‑224, 227‑242, 270‑284 for comprehensive form rebuild patterns.\n- Apply the same pattern for other features (e.g. Help Desk form) so validation and button states update predictably.\n\n**Date Picker Pattern:**\n&#96;&#96;&#96;dart\nConsumer(\n  builder: (context, consRef, child) {\n    return CustomDatePickerField(\n      initialValue: getDateOfBirth(consRef), // From state mixin\n      title: '*${loc.dob}',\n      onSetDateResult: (value) {\n        setDateOfBirth(consRef, value ?? ''); // From event mixin\n      },\n      errorValidation: showErrors &amp;&amp; getDateOfBirth(consRef) == null\n          ? loc.please_complete\n          : null,\n    );\n  },\n)\n&#96;&#96;&#96;\n\n### Form Validation Pattern\n\n**Validation logic must be placed in event mixins** (&#96;*_event.dart&#96;), not in the UI layer. Follow this pattern:\n\n**In Event Mixin** (&#96;help_desk_event.dart&#96; lines 20‑51):\n&#96;&#96;&#96;dart\nFuture&lt;void&gt; submitHelpDesk(\n  WidgetRef ref, {\n  required GlobalKey&lt;FormBuilderState&gt; formKey,\n}) async {\n  // 1. Unfocus keyboard first\n  FocusManager.instance.primaryFocus?.unfocus();\n  \n  // 2. Set show errors flag to trigger validation display\n  ref.read(helpDeskShowErrorsProvider.notifier).state = true;\n  \n  // 3. Validate form builder fields\n  if (formKey.currentState?.saveAndValidate() ?? false) {\n    try {\n      // 4. Extract form values\n      final message = formKey.currentState!.value['message'] as String?;\n      \n      // 5. Read StateProvider values (for dropdowns)\n      final firstCategory = ref.read(helpDeskCategoryProvider);\n      final secondCategory = ref.read(helpDeskSubCategoryProvider);\n      \n      // 6. Additional validation: Check all required fields\n      if (message == null ||\n          message.isEmpty ||\n          firstCategory == null ||\n          secondCategory == null) {\n        return; // Stop if validation fails\n      }\n      \n      // 7. Proceed with API call\n      await ref.watch(helpDeskControllerProvider.notifier)\n          .sendFeedback(message: message);\n      \n      // 8. Reset show errors flag on success\n      ref.read(helpDeskShowErrorsProvider.notifier).state = false;\n    } catch (e, st) {\n      CommonUtils.printAndRecordLog(e, st.toString());\n      rethrow;\n    }\n  }\n}\n&#96;&#96;&#96;\n\n**In UI Layer** (&#96;help_desk_screen.dart&#96; lines 113‑115):\n- Conditionally display validation errors based on &#96;showErrors&#96; flag and field value:\n&#96;&#96;&#96;dart\nCustomDropdownFormField(\n  // ... other properties\n  errorValidation: showErrors &amp;&amp; selectedSubCategory == null\n      ? loc.please_complete\n      : null,\n)\n&#96;&#96;&#96;\n\n**Key Points:**\n- Always unfocus keyboard before validation: &#96;FocusManager.instance.primaryFocus?.unfocus();&#96;\n- Use a &#96;StateProvider.autoDispose&lt;bool&gt;&#96; (e.g., &#96;helpDeskShowErrorsProvider&#96;) to control when validation errors are displayed\n- Set &#96;showErrors = true&#96; before validation, reset to &#96;false&#96; on successful submission\n- Validate both FormBuilder fields (&#96;saveAndValidate()&#96;) AND StateProvider values (dropdown selections)\n- Display errors conditionally: &#96;errorValidation: showErrors &amp;&amp; fieldIsInvalid ? errorMessage : null&#96;\n- Clear errors when user interacts with fields: &#96;setShowHelpDeskErrors(ref, false)&#96; in &#96;onChanged&#96; callbacks\n\n## Pull-to-Refresh Pattern\n\nUse the [&#96;any_refreshable_widget&#96;](https://pub.dev/packages/any_refreshable_widget) package (published by logique.co.id) for implementing pull-to-refresh functionality.\n\n### Setup\n\n**1. Add dependency** (&#96;pubspec.yaml&#96;):\n&#96;&#96;&#96;yaml\ndependencies:\n  any_refreshable_widget: ^0.2.0\n&#96;&#96;&#96;\n\n**2. Create refresh method in event mixin** (&#96;*_event.dart&#96;):\n&#96;&#96;&#96;dart\nFuture&lt;void&gt; refreshHome(WidgetRef ref) async {\n  await Future.wait([\n    ref.refresh(getBannerListProvider.future),\n    ref.refresh(getNewsListProvider.future),\n    ref.refresh(getEventListProvider.future),\n  ]);\n}\n&#96;&#96;&#96;\n\n**Key Points:**\n- Use &#96;ref.refresh(provider.future)&#96; instead of &#96;ref.invalidate()&#96; for better control\n- Use &#96;Future.wait([...])&#96; to refresh multiple providers concurrently\n- Method must return &#96;Future&lt;void&gt;&#96; for async operation\n- Place in event mixin, not directly in UI\n\n**3. Wrap screen body with &#96;AnyRefreshableWidget.single&#96;** (&#96;*_screen.dart&#96;):\n&#96;&#96;&#96;dart\nimport 'package:any_refreshable_widget/any_refreshable_widget.dart';\n\nreturn Scaffold(\n  body: AnyRefreshableWidget.single(\n    onRefresh: () async =&gt; await refreshHome(ref),\n    refreshColor: AppColorTheme.primary500,\n    backgroundColor: AppColorTheme.white,\n    builder: (context, isLoading, error) {\n      return SingleChildScrollView(\n        child: Column(\n          children: [\n            // Your content here\n          ],\n        ),\n      );\n    },\n  ),\n);\n&#96;&#96;&#96;\n\n### Layout Structure Requirements\n\n**IMPORTANT**: When using &#96;AnyRefreshableWidget&#96;, the builder must return a scrollable widget structure:\n\n❌ **Wrong** - Will cause \"RenderFlex unbounded height\" error:\n&#96;&#96;&#96;dart\nAnyRefreshableWidget.single(\n  builder: (context, isLoading, error) {\n    return Column(              // ❌ Column with Expanded\n      children: [\n        SizedBox(height: 200),\n        Expanded(               // ❌ Expanded in scrollable context\n          child: ListView(...), // ❌ Nested scrollable\n        ),\n      ],\n    );\n  },\n)\n&#96;&#96;&#96;\n\n✅ **Correct** - Use &#96;SingleChildScrollView&#96; with &#96;Column&#96;:\n&#96;&#96;&#96;dart\nAnyRefreshableWidget.single(\n  builder: (context, isLoading, error) {\n    return SingleChildScrollView(  // ✅ Single scrollable parent\n      child: Column(                // ✅ Column without Expanded\n        children: [\n          SizedBox(height: 200),\n          Padding(                  // ✅ Use Padding instead of ListView\n            padding: EdgeInsets.symmetric(horizontal: 16.w),\n            child: Column(\n              children: [\n                // All content here\n              ],\n            ),\n          ),\n        ],\n      ),\n    );\n  },\n)\n&#96;&#96;&#96;\n\n### Complete Example Pattern\n\nReference: &#96;home_subscreen.dart&#96; lines 40-116\n\n&#96;&#96;&#96;dart\nclass HomeSubscreen extends ConsumerWidget with HomeEvent, HomeState {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    return Scaffold(\n      body: AnyRefreshableWidget.single(\n        onRefresh: () async =&gt; await refreshHome(ref), // From event mixin\n        refreshColor: AppColorTheme.primary500,\n        backgroundColor: AppColorTheme.white,\n        builder: (context, isLoading, error) {\n          return Stack(\n            children: [\n              SingleChildScrollView(\n                child: Column(\n                  children: [\n                    // Fixed height sections\n                    SizedBox(height: 300, child: CarouselSection()),\n                    \n                    // Content sections\n                    Padding(\n                      padding: EdgeInsets.symmetric(horizontal: 16.w),\n                      child: Column(\n                        children: [\n                          MenuWidget(),\n                          NewsListWidget(),\n                          EventListWidget(),\n                        ],\n                      ),\n                    ),\n                  ],\n                ),\n              ),\n              \n              // Optional: Floating elements\n              Positioned(\n                top: 100,\n                child: FloatingCard(),\n              ),\n            ],\n          );\n        },\n      ),\n    );\n  }\n}\n&#96;&#96;&#96;\n\n### Key Benefits\n\n- ✅ **Concurrent refresh**: Multiple providers refresh simultaneously\n- ✅ **Themed indicator**: Matches app design system\n- ✅ **Smooth UX**: Proper loading states and error handling\n- ✅ **Event mixin pattern**: Follows project architecture\n- ✅ **Single scrollable**: Avoids layout conflicts\n\n## Conditional UI Rendering Based on Authentication\n\nUse &#96;StreamBuilder&#96; with &#96;getAppUserStream&#96; to conditionally show/hide UI sections based on authentication state.\n\n### Pattern\n\n**In Home Screen** (&#96;home_subscreen.dart&#96;):\n&#96;&#96;&#96;dart\nConsumer(\n  builder: (context, consRef, child) {\n    return StreamBuilder(\n      stream: getAppUserStream(consRef),\n      builder: (context, snapshot) {\n        if (snapshot.hasData &amp;&amp; snapshot.data != null) {\n          return Column(\n            children: [gapH16, _buildReportList(loc)],\n          );\n        }\n        return const SizedBox.shrink();\n      },\n    );\n  },\n)\n&#96;&#96;&#96;\n\n**Key Points:**\n- ✅ **Use &#96;StreamBuilder&#96;**: Provides reactive updates when auth state changes\n- ✅ **Check both &#96;hasData&#96; and &#96;data != null&#96;**: Ensures data exists and is not null\n- ✅ **Return &#96;SizedBox.shrink()&#96;**: When condition is false, return empty widget instead of null\n- ✅ **Wrap in &#96;Consumer&#96;**: If accessing Riverpod providers inside the builder\n\n## Horizontal Scrolling Lists\n\nUse &#96;ListView.separated&#96; with &#96;Axis.horizontal&#96; for horizontal scrolling lists with spacing between items.\n\n### Pattern\n\n&#96;&#96;&#96;dart\nSizedBox(\n  height: MediaQuery.sizeOf(context).height * 0.3, // Fixed height\n  child: ListView.separated(\n    scrollDirection: Axis.horizontal,\n    itemCount: items.length,\n    separatorBuilder: (context, index) =&gt; gapW16, // Spacing between items\n    itemBuilder: (context, index) {\n      final item = items[index];\n      return SizedBox(\n        width: MediaQuery.sizeOf(context).width * 0.7, // Item width\n        child: ItemWidget(\n          // ... item properties\n        ),\n      );\n    },\n  ),\n)\n&#96;&#96;&#96;\n\n**Key Points:**\n- ✅ **Use &#96;ListView.separated&#96;**: Better than &#96;ListView.builder&#96; when you need spacing\n- ✅ **Set fixed height**: Required for horizontal &#96;ListView&#96;\n- ✅ **Set item width**: Use &#96;SizedBox&#96; with percentage-based width (e.g., 70% of screen width)\n- ✅ **Use gap constants**: Use &#96;gapW16&#96;, &#96;gapW8&#96;, etc. for consistent spacing\n\n## Widget Extraction for Large Screens\n\nWhen screens become too large (&gt;300 lines), extract complex widgets into separate files in the &#96;widget/&#96; folder.\n\n### Pattern\n\n**Before** (large screen file):\n&#96;&#96;&#96;dart\nclass NewsletterScreen extends ConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    return Scaffold(\n      body: Column(\n        children: [\n          _buildFilterSection(), // 100+ lines\n          _buildTableSection(), // 200+ lines\n        ],\n      ),\n    );\n  }\n}\n&#96;&#96;&#96;\n\n**After** (extracted widgets):\n&#96;&#96;&#96;dart\n// newsletter_screen.dart\nclass NewsletterScreen extends ConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    return Scaffold(\n      body: Column(\n        children: [\n          NewsletterFilterSection(),\n          NewsletterTableSection(),\n        ],\n      ),\n    );\n  }\n}\n\n// widget/newsletter_filter_section.dart\nclass NewsletterFilterSection extends StatelessWidget {\n  // Extracted filter widget\n}\n\n// widget/newsletter_table_section.dart\nclass NewsletterTableSection extends StatelessWidget {\n  // Extracted table widget\n}\n&#96;&#96;&#96;\n\n**Key Points:**\n- ✅ **Extract when &gt;300 lines**: Keep screen files focused and maintainable\n- ✅ **Place in &#96;widget/&#96; folder**: Feature-specific widgets go in &#96;feature/*/presentation/widget/&#96;\n- ✅ **Use descriptive names**: Widget names should clearly indicate their purpose\n- ✅ **Add comments**: Document complex widgets with class-level comments\n\n## Accordion-Style Expandable Sections\n\nUse &#96;AnimatedAlign&#96; with &#96;heightFactor&#96; and &#96;AnimatedRotation&#96; for accordion-style expandable/collapsible sections.\n\n### Pattern\n\n&#96;&#96;&#96;dart\nfinal isExpandedProvider = StateProvider.autoDispose&lt;bool&gt;((ref) =&gt; true);\n\n// In build method\nContainer(\n  child: Column(\n    children: [\n      InkWell(\n        onTap: () =&gt; toggleFilterVisibility(ref),\n        child: Row(\n          children: [\n            Text('Filters'),\n            const Spacer(),\n            AnimatedRotation(\n              turns: isExpanded ? 0 : -0.25,\n              duration: const Duration(milliseconds: 250),\n              child: Icon(Icons.keyboard_arrow_down),\n            ),\n          ],\n        ),\n      ),\n      ClipRect(\n        child: AnimatedAlign(\n          alignment: Alignment.topCenter,\n          duration: const Duration(milliseconds: 300),\n          curve: Curves.easeInOut,\n          heightFactor: isExpanded ? 1 : 0, // Controls expansion\n          child: FormBuilder(\n            // Form content here\n          ),\n        ),\n      ),\n    ],\n  ),\n)\n&#96;&#96;&#96;\n\n**Key Points:**\n- ✅ **Use &#96;AnimatedAlign&#96; with &#96;heightFactor&#96;**: Smoothly expands/collapses content\n- ✅ **Wrap in &#96;ClipRect&#96;**: Prevents overflow during animation\n- ✅ **Use &#96;AnimatedRotation&#96;**: Rotates arrow icon to indicate state\n- ✅ **StateProvider for state**: Use &#96;StateProvider.autoDispose&lt;bool&gt;&#96; to manage expanded state\n- ✅ **Smooth animations**: Use &#96;Curves.easeInOut&#96; for natural feel\n\n## Table Display with Synchronized Scrolling\n\nFor tables with horizontal scrolling, use separate scroll controllers and &#96;NotificationListener&#96; to synchronize header and body scrolling.\n\n### Pattern\n\n&#96;&#96;&#96;dart\nfinal headerScrollController = ScrollController();\nfinal bodyScrollController = ScrollController();\n\n// Listen to body scroll and sync header\nNotificationListener&lt;ScrollNotification&gt;(\n  onNotification: (notification) {\n    if (notification is ScrollUpdateNotification) {\n      headerScrollController.jumpTo(bodyScrollController.offset);\n    }\n    return false;\n  },\n  child: SingleChildScrollView(\n    controller: bodyScrollController,\n    scrollDirection: Axis.horizontal,\n    child: Table(\n      // Table body\n    ),\n  ),\n)\n\n// Header with separate controller\nSingleChildScrollView(\n  controller: headerScrollController,\n  scrollDirection: Axis.horizontal,\n  child: TableHeader(),\n)\n&#96;&#96;&#96;\n\n**Key Points:**\n- ✅ **Separate controllers**: One for header, one for body\n- ✅ **Use &#96;NotificationListener&#96;**: Captures scroll events from body\n- ✅ **Use &#96;jumpTo&#96;**: Synchronizes header position with body\n- ✅ **Handle &#96;ScrollUpdateNotification&#96;**: Only sync on scroll updates, not all notifications\n\n## AppBar Patterns\n\n### Platform-Specific Back Button\n\nAlways use platform-specific back icons in AppBar leading:\n\n&#96;&#96;&#96;dart\nAppBar(\n  backgroundColor: AppColorTheme.primary500,\n  leading: IconButton(\n    onPressed: () =&gt; context.pop(),\n    icon: Icon(\n      Platform.isIOS ? Icons.arrow_back_ios : Icons.arrow_back,\n      color: AppColorTheme.white,\n    ),\n  ),\n  title: Text(\n    loc.personal_info,\n    style: AppTextTheme.semiBoldBase.copyWith(color: AppColorTheme.white),\n  ),\n)\n&#96;&#96;&#96;\n\n- iOS: Use &#96;Icons.arrow_back_ios&#96;\n- Android: Use &#96;Icons.arrow_back&#96;\n- Import &#96;dart:io&#96; to access &#96;Platform&#96;\n- Always apply theming colors consistently (e.g., &#96;AppColorTheme.white&#96; for icons and title text on primary background)\n",
    "languageId": "markdown"
  }
}
```
Result:

```json
{
  "diff": {
    "chunks": [
      {
        "diffString": "  **Imports:**\n  &#96;&#96;&#96;dart\n- import 'package:mm2100_mobile/src/feature/task/presentation/widget/item_task_widget.dart';\n+ import 'package:{{project_name}}/src/feature/task/presentation/widget/item_task_widget.dart';\n  &#96;&#96;&#96;\n  ",
        "oldStart": 884,
        "newStart": 884,
        "oldLines": 5,
        "newLines": 5,
        "linesRemoved": 1,
        "linesAdded": 1
      }
    ],
    "editor": "EDITOR_AI"
  },
  "shouldAutoFixLints": true,
  "resultForModel": "Success. Updated the following files:\nM /Users/cirimin/Logique/Project Starter/project-starter/src/__brick__/{{project_name}}/.cursor/rules/flutter-ui-patterns.mdc",
  "contentsAfterEdit": "---\nglobs: **/presentation/**/*.dart,**/common_widget/**/*.dart\n---\n# Flutter UI Patterns\n\n## Responsive Design\n\nAlways use **Flutter ScreenUtil** for responsive sizing:\n\n- Width: &#96;.w&#96; extension (e.g., &#96;16.w&#96;)\n- Height: &#96;.h&#96; extension (e.g., &#96;24.h&#96;)\n- Font size: &#96;.sp&#96; extension (e.g., &#96;14.sp&#96;)\n- Radius: &#96;.r&#96; extension (e.g., &#96;8.r&#96;)\n\nDesign size is configured in [app.dart](mdc:lib/src/app.dart) as &#96;Size(360, 800)&#96;.\n\n## Spacing\n\nUse predefined gap constants from [app_sizes.dart](mdc:lib/src/theme/app_sizes.dart):\n\n- Horizontal gaps: &#96;gapW4&#96;, &#96;gapW8&#96;, &#96;gapW12&#96;, &#96;gapW16&#96;, etc.\n- Vertical gaps: &#96;gapH4&#96;, &#96;gapH8&#96;, &#96;gapH12&#96;, &#96;gapH16&#96;, etc.\n\nExample:\n&#96;&#96;&#96;dart\nColumn(\n  children: [\n    Text('Title'),\n    gapH16,\n    Text('Content'),\n  ],\n)\n&#96;&#96;&#96;\n\n## Theming\n\nUse theme constants from:\n\n- **Colors**: [app_color_theme.dart](mdc:lib/src/theme/app_color_theme.dart) - &#96;AppColorTheme.primary500&#96;, etc.\n- **Text Styles**: [app_text_theme.dart](mdc:lib/src/theme/app_text_theme.dart) - &#96;AppTextTheme.boldBase&#96;, etc.\n- **Sizes**: [app_sizes.dart](mdc:lib/src/theme/app_sizes.dart) - &#96;Sizes.p16&#96;, etc.\n\nExample:\n&#96;&#96;&#96;dart\nText(\n  'Hello',\n  style: AppTextTheme.boldBase.copyWith(\n    color: AppColorTheme.primary500,\n  ),\n)\n&#96;&#96;&#96;\n\n## Localization\n\nAlways use localization for user-facing strings:\n\n1. **Use &#96;LocalizationMixin&#96;** - The preferred way to access localization in UI layer\n2. Use generated keys: &#96;loc.appTitle&#96;, &#96;loc.view_all&#96;, etc.\n3. Add translations to &#96;.arb&#96; files in &#96;lib/src/localization/&#96;\n4. Run &#96;flutter gen-l10n&#96; to generate localization classes\n\n### Using LocalizationMixin\n\nThe [LocalizationMixin](mdc:lib/src/core/mixins/localization_mixin.dart) provides all localization operations:\n\n&#96;&#96;&#96;dart\n// ✅ Correct: Use LocalizationMixin in UI layer\nclass HomeSubscreen extends ConsumerWidget with HomeEvent, HomeState, LocalizationMixin {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final loc = getLocalizations(ref); // Get AppLocalizations\n    final locale = getLocale(ref); // Get locale string ('en' or 'id')\n    final localeNumber = getLocaleToNumber(ref); // Get locale number (en=2, id=1)\n    \n    // Change locale\n    await setLocalization('en', ref);\n    \n    return Text(loc.appTitle);\n  }\n}\n&#96;&#96;&#96;\n\n**Available methods:**\n- &#96;getLocalizations(WidgetRef ref)&#96; - Returns &#96;AppLocalizations&#96; instance\n- &#96;getLocale(WidgetRef ref)&#96; - Returns locale string ('en' or 'id')\n- &#96;getLocaleToNumber(WidgetRef ref)&#96; - Returns locale number (en=2, id=1)\n- &#96;setLocalization(String locale, WidgetRef ref)&#96; - Changes app locale\n\n**Note**: Event/State mixins can use &#96;ref.watch(appLocalizationsProvider)&#96; directly since they're not UI layer files.\n\nNever hardcode user-facing strings. See [string_hardcoded.dart](mdc:lib/src/localization/string_hardcoded.dart) for exceptions.\n\n## Widget Structure\n\n### Screen Widgets\n\n- Use &#96;ConsumerWidget&#96; or &#96;ConsumerStatefulWidget&#96; for Riverpod integration\n- Use mixins for shared behavior (e.g., &#96;with HomeEvent, HomeState&#96;)\n- Extract complex UI into separate widget methods (prefixed with &#96;_&#96;)\n\nExample from [home_subscreen.dart](mdc:lib/src/feature/home/presentation/home_subscreen.dart):\n&#96;&#96;&#96;dart\nclass HomeSubscreen extends ConsumerWidget with HomeEvent, HomeState, LocalizationMixin {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final loc = getLocalizations(ref); // From LocalizationMixin\n    // Implementation\n  }\n  \n  Widget _buildNewsList(AppLocalizations loc) {\n    // Private widget method\n  }\n}\n&#96;&#96;&#96;\n\n## Riverpod Provider Access in UI Layer\n\n**IMPORTANT**: Never use &#96;ref.watch()&#96; or &#96;ref.read()&#96; directly in UI layer files.\n\n### Rules\n\n1. **&#96;ref.watch()&#96; and &#96;ref.read()&#96;**: Must be encapsulated in state/event mixins\n   - Create methods in &#96;*_state.dart&#96; mixins for &#96;ref.watch()&#96; calls\n   - Create methods in &#96;*_event.dart&#96; mixins for &#96;ref.read()&#96; calls\n   - Call these mixin methods from the UI layer\n\n2. **&#96;ref.listen()&#96;**: Allowed in UI layer for side effects\n   - Use for showing snackbars, navigation callbacks, handling async results, etc.\n   - Must be called in the &#96;build&#96; method, typically at the beginning after getting localization\n\n### Listening to Async Results\n\nWhen listening to controller providers that return &#96;AsyncValue&#96;, use this pattern to handle errors and success states:\n\n**Pattern for Async Operations** (&#96;forgot_password_screen.dart&#96; lines 30‑49):\n&#96;&#96;&#96;dart\nref.listen&lt;AsyncValue&gt;(forgotPasswordControllerProvider, (prev, next) {\n  // Handle error state\n  if (next is AsyncError) {\n    if (!next.isRefreshing &amp;&amp; next.hasError) {\n      CustomSnackbar.show(\n        context,\n        CustomSnackbarMode.error,\n        next.error.toString(),\n      );\n    }\n  }\n  // Handle success state (transition from loading to data)\n  else if (next is AsyncData &amp;&amp; prev is AsyncLoading) {\n    if (context.mounted) {\n      CustomSnackbar.show(\n        context,\n        CustomSnackbarMode.success,\n        next.value?.message ?? '',\n      );\n      context.pop(); // Navigate back on success\n    }\n  }\n});\n&#96;&#96;&#96;\n\n**Key Points:**\n- **Error handling**: Check &#96;next is AsyncError&#96; and &#96;!next.isRefreshing&#96; to avoid showing errors during refresh\n- **Success handling**: Check &#96;next is AsyncData &amp;&amp; prev is AsyncLoading&#96; to detect successful completion\n- **Context safety**: Always check &#96;context.mounted&#96; before navigation or context-dependent operations\n- **Message extraction**: Use &#96;next.value?.message&#96; for API response messages, or provide fallback strings\n- **Navigation**: Use &#96;context.pop()&#96; or &#96;goToXxx(ref)&#96; from event mixins after successful operations\n\n**Additional Examples:**\n- &#96;help_desk_screen.dart&#96; lines 36‑54: Help desk form submission\n- &#96;account_screen.dart&#96; lines 36‑54: Logout operation\n- &#96;register_screen.dart&#96; lines 42‑60: Registration form submission\n\n### Correct Pattern\n\n&#96;&#96;&#96;dart\n// ✅ In *_state.dart mixin\nmixin class HomeState {\n  AsyncValue&lt;NewsListResponse?&gt; getNewsList(WidgetRef ref) =&gt;\n      ref.watch(getNewsListProvider);\n}\n\n// ✅ In UI layer\nclass HomeSubscreen extends ConsumerWidget with HomeState {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final newsList = getNewsList(ref); // Call mixin method\n    // ...\n  }\n}\n&#96;&#96;&#96;\n\n### Incorrect Pattern\n\n&#96;&#96;&#96;dart\n// ❌ Wrong: Direct ref.watch in UI layer\nclass HomeSubscreen extends ConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final newsList = ref.watch(getNewsListProvider); // Don't do this!\n    // ...\n  }\n}\n&#96;&#96;&#96;\n\n### Common Widgets\n\nReusable widgets should be placed in:\n- &#96;lib/src/common_widget/&#96; - App-wide reusable widgets\n- &#96;lib/src/feature/*/presentation/widget/&#96; - Feature-specific widgets\n\n## Navigation\n\nUse GoRouter for navigation via event mixins (never directly in UI layer):\n\n&#96;&#96;&#96;dart\n// ✅ In *_event.dart mixin\nmixin class HomeEvent {\n  void goToNewsDetail(WidgetRef ref, String newsId) {\n    ref.read(goRouterProvider).goNamed(\n      AppRoute.newsDetail.name,\n      pathParameters: {'currentIndex': '0'},\n      queryParameters: {'newsId': newsId},\n    );\n  }\n}\n\n// ✅ In UI layer - call mixin method\ngoToNewsDetail(ref, newsId);\n&#96;&#96;&#96;\n\nRoute definitions are in [app_router.dart](mdc:lib/src/routing/app_router.dart).\n\n## Loading States\n\nUse [AsyncValueWidget](mdc:lib/src/common_widget/async_value_widget.dart) for async data:\n\n&#96;&#96;&#96;dart\nAsyncValueWidget(\n  value: getNewsList(ref),\n  data: (newsList) =&gt; ListView(/* ... */),\n  loading: () =&gt; CircularProgressIndicator(),\n  error: (error, stack) =&gt; ErrorWidget(error),\n)\n&#96;&#96;&#96;\n\n### Shimmer Loading Placeholders\n\nFor loading placeholders in lists, grids, or tables, use [ShimmerLoadingItem](mdc:lib/src/common_widget/shimmer_loading_item.dart) instead of &#96;CircularProgressIndicator&#96;:\n\n**Pattern with AsyncValueWidget:**\n&#96;&#96;&#96;dart\nAsyncValueWidget(\n  value: getNewsList(ref),\n  customLoading: const ShimmerLoadingItem(), // Use shimmer for list loading\n  data: (newsList) =&gt; ListView(/* ... */),\n)\n&#96;&#96;&#96;\n\n**Pattern with AsyncValue.when() (for paginated lists):**\n&#96;&#96;&#96;dart\nListView.builder(\n  itemCount: totalResults ?? 0,\n  itemBuilder: (context, index) {\n    final res = getPageValue(page);\n    return res.when(\n      loading: () =&gt; const ShimmerLoadingItem(), // Shimmer for each item\n      error: (error, stackTrace) =&gt; /* handle error */,\n      data: (response) =&gt; /* build item */,\n    );\n  },\n)\n&#96;&#96;&#96;\n\n**Key Points:**\n- ✅ **Use for lists/grids**: &#96;ShimmerLoadingItem&#96; provides better UX for list-based loading\n- ✅ **Use in itemBuilder**: When using &#96;AsyncValue.when()&#96; inside &#96;ListView.builder&#96;, use shimmer for each loading item\n- ✅ **Consistent appearance**: Shimmer matches the layout structure of actual items\n- ✅ **Better than CircularProgressIndicator**: More appropriate for list-based content\n\n### Handling Empty Data and Errors\n\nWhen displaying lists or tables, show a single \"No Data\" message when:\n1. An error occurs during data loading\n2. The result is empty (no items)\n\n**Pattern for Paginated Lists (using AsyncValue.when()):**\n&#96;&#96;&#96;dart\nListView.builder(\n  itemCount: totalResults ?? 0,\n  itemBuilder: (context, index) {\n    final res = getPageValue(page);\n    return res.when(\n      // Show single \"No data\" message if page load failed (only on first item)\n      error: (error, stackTrace) =&gt; index == 0\n          ? Padding(\n              padding: EdgeInsets.all(16.w),\n              child: Text(\n                'No Data'.hardcoded,\n                style: AppTextTheme.regularSm,\n                textAlign: TextAlign.center,\n              ),\n            )\n          : const SizedBox.shrink(), // Hide for other items\n      // Show loading shimmer while page is loading\n      loading: () =&gt; const ShimmerLoadingItem(),\n      // Build item when data is available\n      data: (response) {\n        final items = extractItems(response);\n        if (items == null || items.isEmpty) {\n          return index == 0\n              ? Padding(\n                  padding: EdgeInsets.all(16.w),\n                  child: Text(\n                    'No Data'.hardcoded,\n                    style: AppTextTheme.regularSm,\n                    textAlign: TextAlign.center,\n                  ),\n                )\n              : const SizedBox.shrink();\n        }\n        // Build actual item\n        return ItemWidget(item: items[indexInPage]);\n      },\n    );\n  },\n)\n&#96;&#96;&#96;\n\n**Pattern for Simple Lists (using AsyncValueWidget):**\n&#96;&#96;&#96;dart\nAsyncValueWidget(\n  value: getDataList(ref),\n  data: (dataList) {\n    final items = dataList?.data ?? [];\n    // Show \"No Data\" if list is empty\n    if (items.isEmpty) {\n      return Center(\n        child: Text(\n          'No Data'.hardcoded,\n          style: AppTextTheme.regularSm,\n        ),\n      );\n    }\n    return ListView.builder(\n      itemCount: items.length,\n      itemBuilder: (context, index) =&gt; ItemWidget(item: items[index]),\n    );\n  },\n)\n&#96;&#96;&#96;\n\n**Pattern for Initial Loading Check:**\n&#96;&#96;&#96;dart\n// Check initial loading state before building list\nif (firstPageValue.isLoading ||\n    firstPageValue.isRefreshing ||\n    firstPageValue.isReloading) {\n  return const ShimmerLoadingItem(); // Or Center(child: CircularProgressIndicator())\n}\n\n// Check if data is empty\nfinal totalResults = extractTotal(firstPageValue.value);\nif (totalResults == 0) {\n  return Center(\n    child: Text(\n      'Data not found'.hardcoded,\n      style: AppTextTheme.regularSm,\n    ),\n  );\n}\n\n// Build list with data\nreturn ListView.builder(/* ... */);\n&#96;&#96;&#96;\n\n**Key Points:**\n- ✅ **Show once**: Use &#96;index == 0&#96; check to show \"No Data\" message only once in paginated lists\n- ✅ **Use &#96;SizedBox.shrink()&#96;**: Return empty widget for other indices when showing error/empty message\n- ✅ **Consistent messaging**: Use hardcoded strings like &#96;'No Data'.hardcoded&#96; or &#96;'Data not found'.hardcoded&#96;\n- ✅ **Center alignment**: Center the message for better visibility\n- ✅ **Check both error and empty**: Handle both error states and empty data states\n- ✅ **Padding**: Add padding around the message for better spacing\n\n## Pagination Display Patterns\n\nThis project uses **four standardized pagination layouts** to ensure every feature behaves consistently. All patterns share the same contract:\n\n### Common Contract for All Pagination Patterns\n\nEvery paginated view requires these parameters:\n\n- **&#96;firstPageValue&#96;**: &#96;AsyncValue&#96; for page 1, used for initial loading/empty state checks\n- **&#96;getPageValue&#96;**: Callback &#96;(int page) =&gt; AsyncValue&lt;Response&gt;&#96; that fetches a specific page\n- **&#96;extractTotal&#96;**: Function &#96;(Response?) =&gt; int?&#96; that extracts total item count from API response\n- **&#96;extractItems&#96;**: Function &#96;(Response?) =&gt; List&lt;Item&gt;?&#96; that extracts the data list from API response\n- **&#96;onRefresh&#96;**: Callback &#96;() async =&gt; void&#96; that invalidates providers (must be in event mixin, never in UI)\n- **&#96;buildItem&#96;**: Function &#96;(BuildContext, Item) =&gt; Widget&#96; that renders a single item widget\n\n### Pattern 1: Standard ListView (Vertical Scrolling List)\n\n**Use when:** Displaying a simple paginated list without categories (e.g., notifications, tasks, reports)\n\n**Reference:** &#96;notification_screen.dart&#96;, &#96;task_screen.dart&#96;\n\n**Structure:**\n&#96;&#96;&#96;dart\nclass NotificationScreen extends ConsumerWidget \n    with NotificationState, NotificationEvent, LocalizationMixin {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final loc = getLocalizations(ref);\n    return Scaffold(\n      appBar: AppBar(/* ... */),\n      body: Column(\n        children: [\n          gapH16,\n          Expanded(\n            child: Consumer(\n              builder: (context, consRef, child) {\n                return CategorizedTabBodyView&lt;NotificationResponse, NotificationData&gt;(\n                  categoryId: 0, // No category\n                  viewType: ViewType.listView,\n                  firstPageValue: getNotificationList(consRef, page: 1),\n                  getPageValue: (page) =&gt; getNotificationList(consRef, page: page),\n                  extractTotal: (data) =&gt; data?.data?.total,\n                  extractItems: (data) =&gt; data?.data?.notificationData,\n                  onRefresh: () async =&gt; onRefresh(consRef),\n                  buildItem: (context, item) =&gt; ItemNotificationWidget(/* ... */),\n                );\n              },\n            ),\n          ),\n        ],\n      ),\n    );\n  }\n}\n&#96;&#96;&#96;\n\n**Key Points:**\n- Use &#96;Column&#96; with &#96;gapH16&#96; + &#96;Expanded&#96; + &#96;Consumer&#96; wrapper\n- Set &#96;categoryId: 0&#96; when no categories exist\n- Set &#96;viewType: ViewType.listView&#96; (default)\n- &#96;CategorizedTabBodyView&#96; handles infinite scroll, shimmer, empty states automatically\n- Always use &#96;Consumer&#96; to properly scope Riverpod refs\n\n### Pattern 2: TableView With Fixed Header &amp; Filters\n\n**Use when:** Displaying tabular data with filterable columns and synchronized horizontal scrolling\n\n**Reference:** &#96;newsletter_screen.dart&#96;\n\n**Structure:**\n&#96;&#96;&#96;dart\nclass NewsletterScreen extends ConsumerWidget \n    with NewsletterState, NewsletterEvent, LocalizationMixin {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    return Scaffold(\n      appBar: AppBar(/* ... */),\n      body: LayoutBuilder(\n        builder: (context, constraints) {\n          // Calculate available height for table\n          final screenHeight = MediaQuery.sizeOf(context).height;\n          final appBarHeight = AppBar().preferredSize.height;\n          final statusBarHeight = MediaQuery.paddingOf(context).top;\n          final keyboardHeight = MediaQuery.viewInsetsOf(context).bottom;\n          final availableHeight = screenHeight - appBarHeight - statusBarHeight - keyboardHeight;\n          \n          final filterHeight = isFilterExpanded ? 450.h : 60.h;\n          final tableHeight = availableHeight - filterHeight - margins;\n          \n          return SingleChildScrollView(\n            child: Column(\n              children: [\n                _buildFilterAccordion(loc), // Collapsible filter form\n                gapH16,\n                SizedBox(\n                  height: tableHeight,\n                  child: _buildTableWithPagination(context, ref),\n                ),\n              ],\n            ),\n          );\n        },\n      ),\n    );\n  }\n  \n  Widget _buildTableWithPagination(BuildContext context, WidgetRef ref) {\n    final loc = getLocalizations(ref);\n    final firstPageValue = ref.watch(getNewsletterListProvider(page: 1));\n    \n    return NewsletterTableWithHeader(\n      firstPageValue: firstPageValue,\n      getPageValue: (page) =&gt; ref.watch(getNewsletterListProvider(page: page)),\n      extractTotal: (data) =&gt; data?.data?.total,\n      extractItems: (data) =&gt; data?.data?.data,\n      onRefresh: () async =&gt; ref.invalidate(getNewsletterListProvider(page: 1)),\n      onOpenAttachment: (pdfPath) =&gt; openAttachment(context, pdfPath),\n      loc: loc,\n    );\n  }\n}\n&#96;&#96;&#96;\n\n**Key Points:**\n- Use &#96;LayoutBuilder&#96; to calculate dynamic table height based on screen size and filter state\n- Wrap table in fixed-height &#96;SizedBox&#96; to prevent layout overflow\n- &#96;NewsletterTableWithHeader&#96; synchronizes horizontal scroll between header and body rows\n- Filter form should be collapsible (accordion pattern) to maximize table space\n- &#96;onRefresh&#96; only invalidates page 1 to preserve filter state\n- Always pass &#96;loc&#96; for localized column headers\n\n### Pattern 3: GridView With Category Tabs\n\n**Use when:** Displaying categorized content in a grid layout with tab navigation\n\n**Reference:** &#96;company_screen.dart&#96;, &#96;amenities_screen.dart&#96;\n\n**Structure:**\n&#96;&#96;&#96;dart\nclass CompanyScreen extends ConsumerWidget \n    with CompanyState, CompanyEvent, LocalizationMixin {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final loc = getLocalizations(ref);\n    return Scaffold(\n      appBar: AppBar(/* ... */),\n      body: Consumer(\n        builder: (context, consRef, child) {\n          return CategorizedTabView&lt;\n            CompanyCategoryListResponse,\n            CompanyCategoryData,\n            CompanyListResponse\n          &gt;(\n            categoriesValue: getCompanyCategoryList(consRef),\n            extractCategories: (data) =&gt; data?.companyCategoryData,\n            buildTabBarViewChild: (context, consRef, category) {\n              return CategorizedTabBodyView&lt;CompanyListResponse, CompanyData&gt;(\n                categoryId: category.id ?? 0,\n                viewType: ViewType.gridView,\n                firstPageValue: getCompanyListByCategory(\n                  consRef,\n                  page: 1,\n                  categoryId: category.id ?? 0,\n                ),\n                getPageValue: (page) =&gt; getCompanyListByCategory(\n                  consRef,\n                  page: page,\n                  categoryId: category.id ?? 0,\n                ),\n                extractTotal: (data) =&gt; data?.data?.total,\n                extractItems: (data) =&gt; data?.data?.companyData,\n                onRefresh: () async =&gt; onRefresh(consRef, category.id ?? 0),\n                buildItem: (context, item) =&gt; ItemSpotWidget(/* ... */),\n              );\n            },\n            onSearchSubmitted: (value) =&gt; onSearchSubmitted(consRef, value ?? ''),\n          );\n        },\n      ),\n    );\n  }\n}\n&#96;&#96;&#96;\n\n**Key Points:**\n- Use &#96;CategorizedTabView&#96; as top-level widget for tab management\n- &#96;categoriesValue&#96; fetches category list from state mixin\n- &#96;extractCategories&#96; maps API response to category list\n- &#96;buildTabBarViewChild&#96; returns &#96;CategorizedTabBodyView&#96; for each tab\n- Each tab has **isolated pagination** scoped to &#96;category.id&#96;\n- Set &#96;viewType: ViewType.gridView&#96; for 2-column grid layout\n- &#96;onRefresh&#96; invalidates both category list and active category's data\n- Optional &#96;onSearchSubmitted&#96; for search functionality across all tabs\n\n### Pattern 4: GridView Without Tabs (Simple Grid)\n\n**Use when:** Displaying grid content without categories (e.g., embed links, others)\n\n**Reference:** &#96;embed_screen.dart&#96;\n\n**Structure:**\n&#96;&#96;&#96;dart\nclass EmbedScreen extends ConsumerWidget \n    with EmbedState, EmbedEvent, LocalizationMixin {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final loc = getLocalizations(ref);\n    return Scaffold(\n      appBar: AppBar(/* ... */),\n      body: Column(\n        children: [\n          gapH16,\n          Expanded(\n            child: Consumer(\n              builder: (context, consRef, child) {\n                return CategorizedTabBodyView&lt;EmbedListResponse, EmbedData&gt;(\n                  categoryId: 0, // No category\n                  viewType: ViewType.gridView,\n                  itemAspectRatio: 1.1, // Optional: control tile proportions\n                  firstPageValue: getEmbedList(consRef, page: 1),\n                  getPageValue: (page) =&gt; getEmbedList(consRef, page: page),\n                  extractTotal: (data) =&gt; data?.data?.total,\n                  extractItems: (data) =&gt; data?.data?.data,\n                  onRefresh: () async =&gt; onRefresh(consRef),\n                  buildItem: (context, item) {\n                    final localeNumber = getLocaleToNumber(ref);\n                    final title = localeNumber == 1 ? item.titleId : item.titleEn;\n                    return ItemEmbedWidget(\n                      imageUrl: item.image ?? '',\n                      title: title ?? '',\n                      onTap: () =&gt; launchEmbedUrl(context, item.link, title ?? ''),\n                    );\n                  },\n                );\n              },\n            ),\n          ),\n        ],\n      ),\n    );\n  }\n}\n&#96;&#96;&#96;\n\n**Key Points:**\n- Similar to Pattern 1 (ListView) but with &#96;viewType: ViewType.gridView&#96;\n- Set &#96;categoryId: 0&#96; when no categories exist\n- Use &#96;itemAspectRatio&#96; to control grid tile width/height ratio (default is calculated automatically)\n- Locale-specific content (title/description) handled in &#96;buildItem&#96; via &#96;LocalizationMixin&#96;\n- Grid automatically displays 2 columns with responsive spacing\n\n### Pattern Selection Guide\n\n| Pattern | Use Case | Has Categories? | Layout | Example Features |\n|---------|----------|----------------|--------|------------------|\n| **Pattern 1: ListView** | Simple vertical list | No | Vertical scroll | Notifications, Tasks |\n| **Pattern 2: TableView** | Tabular data with filters | No | Table with fixed header | Newsletter, Reports |\n| **Pattern 3: GridView + Tabs** | Categorized grid content | Yes | Grid with tabs | Company, Amenities |\n| **Pattern 4: GridView** | Simple grid content | No | Grid without tabs | Embed/Others |\n\n### Benefits of These Patterns\n\n- ✅ **Consistent UX**: All features use the same pagination, loading, and error handling\n- ✅ **Automatic infinite scroll**: &#96;CategorizedTabBodyView&#96; handles pagination automatically\n- ✅ **Built-in shimmer states**: Loading placeholders shown during data fetch\n- ✅ **Empty/error handling**: Centralized \"No Data\" and error messages\n- ✅ **Pull-to-refresh**: Integrated refresh indicator (when &#96;onRefresh&#96; provided)\n- ✅ **Scroll position preservation**: PageStorageKey maintains scroll when switching tabs\n\n### Fetching Paginated Data From the API\n\nAll paginated widgets rely on repository providers that follow a standardized contract. This ensures consistency across features and proper integration with the pagination UI patterns.\n\n#### Repository Provider Structure\n\n**1. Provider Declaration**\n\nDeclare a &#96;@riverpod&#96; function that accepts a &#96;page&#96; parameter plus any filters (category ID, search keyword, etc.):\n\n&#96;&#96;&#96;dart\n@riverpod\nFuture&lt;NotificationResponse?&gt; getNotificationList(\n  Ref ref, {\n  required int page,\n}) async {\n  try {\n    final dio = ref.watch(dioConfigProvider);\n    final userId = ref.watch(authRepositoryProvider).currentUser?.userId;\n    \n    // Early return if required data is missing\n    if (userId == null) return null;\n\n    final response = await dio.post(\n      '/api/v1/getnotificationlist',\n      data: {\n        'user_id': userId,\n        'limit': Constants.limit,\n        'language_id': ref.watch(localeProviderToNumber),\n        'page': page,\n      },\n      cancelToken: ref.cancelToken(),\n    );\n    \n    return NotificationResponse.fromJson(response.data);\n  } on DioException catch (error) {\n    throw onDioError(error);\n  } catch (e) {\n    rethrow;\n  }\n}\n&#96;&#96;&#96;\n\n**2. Required Request Payload Fields**\n\nEvery paginated API call must include:\n\n- **&#96;limit&#96;**: Use &#96;Constants.limit&#96; (typically 10 or 20) for consistency across all features\n- **&#96;page&#96;**: Forward the method parameter directly (1-indexed)\n- **&#96;language_id&#96;**: Read from &#96;ref.watch(localeProviderToNumber)&#96; for localized responses\n- **Additional filters**: Read from &#96;StateProvider&#96;s (e.g., &#96;categoryId&#96;, &#96;search&#96;, &#96;year&#96;, &#96;month&#96;)\n\n**3. Cancel Token Management**\n\nAlways use &#96;ref.cancelToken()&#96; to automatically cancel in-flight requests when:\n- Widget is disposed\n- User navigates away\n- New request is triggered\n\n&#96;&#96;&#96;dart\ncancelToken: ref.cancelToken(), // Automatic cleanup\n&#96;&#96;&#96;\n\n**4. Error Handling Pattern**\n\nWrap all network calls in try-catch with proper error conversion:\n\n&#96;&#96;&#96;dart\ntry {\n  // API call\n} on DioException catch (error) {\n  throw onDioError(error); // Convert to user-friendly message\n} catch (e) {\n  rethrow; // Preserve unknown errors\n}\n&#96;&#96;&#96;\n\n**Key Points:**\n- Keep repositories thin—no UI logic, no logging side effects\n- Return &#96;null&#96; for missing required data (e.g., &#96;userId == null&#96;)\n- Use &#96;onDioError()&#96; helper to convert &#96;DioException&#96; to readable error messages\n- Never catch errors silently—always rethrow or convert\n\n#### Filter State Management\n\n**5. Form-Driven Filter Submission Pattern**\n\nWhen filters should only apply after user taps a submit button (not on every dropdown change):\n\n**Step 1: Create Local StateProviders** (in screen file)\n&#96;&#96;&#96;dart\n// Local state for form selections (not used by repository yet)\nfinal localCategoryIdProvider = StateProvider.autoDispose&lt;int&gt;((ref) =&gt; 0);\nfinal localYearProvider = StateProvider.autoDispose&lt;int&gt;((ref) =&gt; 0);\nfinal localMonthProvider = StateProvider.autoDispose&lt;int&gt;((ref) =&gt; 0);\n&#96;&#96;&#96;\n\n**Step 2: Create Global StateProviders** (in controller file)\n&#96;&#96;&#96;dart\n// Global state used by repository\nfinal newsletterCategoryIdProvider = StateProvider.autoDispose&lt;int&gt;((ref) =&gt; 0);\nfinal newsletterYearProvider = StateProvider.autoDispose&lt;int&gt;((ref) =&gt; 0);\nfinal newsletterMonthProvider = StateProvider.autoDispose&lt;int&gt;((ref) =&gt; 0);\nfinal newsletterKeywordProvider = StateProvider.autoDispose&lt;String&gt;((ref) =&gt; '');\n&#96;&#96;&#96;\n\n**Step 3: Repository Reads Global Providers**\n&#96;&#96;&#96;dart\n@riverpod\nFuture&lt;NewsletterResponse?&gt; getNewsletterList(\n  Ref ref, {\n  required int page,\n}) async {\n  final dio = ref.watch(dioConfigProvider);\n  \n  // Read from global providers (not local ones)\n  final categoryId = ref.watch(newsletterCategoryIdProvider);\n  final search = ref.watch(newsletterKeywordProvider);\n  final month = ref.watch(newsletterMonthProvider);\n  final year = ref.watch(newsletterYearProvider);\n  \n  final response = await dio.post(\n    '/api/v1/getnewsletterlist',\n    data: {\n      'limit': Constants.limit,\n      'page': page,\n      'category_id': categoryId,\n      'search': search,\n      if (month != 0) 'month': month, // Conditional fields\n      if (year != 0) 'year': year,\n    },\n    cancelToken: ref.cancelToken(),\n  );\n  \n  return NewsletterResponse.fromJson(response.data);\n}\n&#96;&#96;&#96;\n\n**Step 4: Event Mixin Copies Local → Global on Submit**\n\n&#96;&#96;&#96;dart\nmixin class NewsletterEvent {\n  static const String keyKeyword = 'keyword';\n\n  Future&lt;void&gt; onSubmitSearchNewsletter(\n    WidgetRef ref,\n    GlobalKey&lt;FormBuilderState&gt; formKey,\n  ) async {\n    // 1. Unfocus keyboard\n    FocusManager.instance.primaryFocus?.unfocus();\n\n    // 2. Validate form\n    if (formKey.currentState?.saveAndValidate() ?? false) {\n      // 3. Extract form values\n      final keyword = formKey.currentState!.value[keyKeyword] as String? ?? '';\n\n      // 4. Copy local state → global state (used by repository)\n      ref.read(newsletterKeywordProvider.notifier).state = keyword;\n      ref.read(newsletterCategoryIdProvider.notifier).state =\n          ref.read(localCategoryIdProvider);\n      ref.read(newsletterYearProvider.notifier).state =\n          ref.read(localYearProvider);\n      ref.read(newsletterMonthProvider.notifier).state =\n          ref.read(localMonthProvider);\n\n      // 5. Invalidate page 1 to trigger new API call with updated filters\n      ref.invalidate(getNewsletterListProvider(page: 1));\n    }\n  }\n}\n&#96;&#96;&#96;\n\n**Why This Pattern?**\n\nThis two-tier state approach ensures predictable filter behavior:\n\n- ✅ **No premature API calls**: Users can adjust dropdowns/dates without triggering requests\n- ✅ **Explicit submission**: API only fires when user taps \"Search\" button\n- ✅ **State isolation**: Local providers hold \"draft\" values, global providers hold \"committed\" values\n- ✅ **Repository simplicity**: Repository only reads global providers, never UI state\n- ✅ **Consistent UX**: All filterable features (newsletter, reports, etc.) behave the same way\n\n**When to Use:**\n- ✅ Use this pattern when filters have a submit button\n- ❌ Don't use for instant search (where each keystroke triggers API)\n- ❌ Don't use for category tabs (where tab change should immediately load data)\n\n## Item Widgets &amp; Display Lists\n\nEvery scrolling surface (paginated or not) must separate the **collection widget** from the **single-item widget** for maintainability and reusability.\n\n### Widget Separation Pattern\n\n**Collection Widget** (Screen/Subscreen)\n- Sets up the overall layout (AppBar, Scaffold, Column structure)\n- Fetches data via state mixins (&#96;getNotificationList&#96;, &#96;getTaskList&#96;, etc.)\n- Decides view type: &#96;ListView&#96;, &#96;GridView&#96;, or table\n- Handles pagination setup (&#96;CategorizedTabBodyView&#96; or &#96;AsyncValueWidget&#96;)\n- Manages pull-to-refresh and empty/error states\n\n**Item Widget** (Reusable Component)\n- Renders a single data item\n- Stateless and purely presentational\n- Filename starts with &#96;item_&#96; prefix\n- Lives in &#96;feature/*/presentation/widget/&#96; folder\n\n### Naming Conventions\n\n**Files** (snake_case):\n- &#96;item_task_widget.dart&#96;\n- &#96;item_notification_widget.dart&#96;\n- &#96;item_embed_widget.dart&#96;\n- &#96;item_spot_widget.dart&#96;\n- &#96;item_news_widget.dart&#96;\n- &#96;item_event_widget.dart&#96;\n- &#96;item_report_widget.dart&#96;\n\n**Classes** (PascalCase):\n- &#96;ItemTaskWidget&#96;\n- &#96;ItemNotificationWidget&#96;\n- &#96;ItemEmbedWidget&#96;\n- &#96;ItemSpotWidget&#96;\n- &#96;ItemNewsWidget&#96;\n- &#96;ItemEventWidget&#96;\n- &#96;ItemReportWidget&#96;\n\n**Domain Models** (for list items):\n- Files: &#96;item_faq.dart&#96; (not &#96;faq_item.dart&#96;)\n- Classes: &#96;ItemFaq&#96; (not &#96;FaqItem&#96;)\n\n**Imports:**\n&#96;&#96;&#96;dart\nimport 'package:{{project_name}}/src/feature/task/presentation/widget/item_task_widget.dart';\n&#96;&#96;&#96;\n\n### Building Item Widgets\n\nFollow these principles when creating item widgets:\n\n**1. Always Stateless**\n&#96;&#96;&#96;dart\nclass ItemTaskWidget extends StatelessWidget {\n  const ItemTaskWidget({super.key, required this.task, this.onTap});\n  \n  final TaskData task;\n  final VoidCallback? onTap;\n  \n  @override\n  Widget build(BuildContext context) {\n    // Render logic\n  }\n}\n&#96;&#96;&#96;\n\n**2. Accept Domain Model + Callbacks**\n- Primary data: Domain model (e.g., &#96;TaskData task&#96;, &#96;NotificationData notification&#96;)\n- Interaction: Nullable &#96;VoidCallback? onTap&#96; for navigation\n- Avoid passing &#96;WidgetRef&#96; or state providers—keep it pure\n\n**3. Handle Formatting Locally**\n&#96;&#96;&#96;dart\n@override\nWidget build(BuildContext context) {\n  // Format dates/numbers inside the widget\n  final formattedDate = CommonUtils.formatDateWithLocale(\n    task.date,\n    dateFormat: 'dd MMMM yyyy',\n  );\n  \n  return Container(/* ... */);\n}\n&#96;&#96;&#96;\n\n**4. Use Theme Constants**\n&#96;&#96;&#96;dart\nText(\n  task.number ?? '-',\n  style: AppTextTheme.semiBoldBase.copyWith(\n    color: AppColorTheme.blackRock500,\n  ),\n)\n&#96;&#96;&#96;\n\n**5. Encapsulate Repeated UI Elements**\n\nIf the item has repeated chips/badges/tags, create private helper widgets/classes:\n\n&#96;&#96;&#96;dart\nclass ItemTaskWidget extends StatelessWidget {\n  // Main widget code\n  \n  Widget _buildInOutChip(String? value) {\n    if (value == null || value.isEmpty) return const SizedBox.shrink();\n    return Container(/* chip UI */);\n  }\n  \n  Color _statusChipColor(String? value) {\n    // Color logic\n  }\n}\n\n// Private helper class for complex chips\nclass _StatusChip extends StatelessWidget {\n  const _StatusChip({\n    required this.label,\n    required this.backgroundColor,\n    required this.textColor,\n  });\n  \n  final String label;\n  final Color backgroundColor;\n  final Color textColor;\n  \n  @override\n  Widget build(BuildContext context) {\n    return Container(/* ... */);\n  }\n}\n&#96;&#96;&#96;\n\n### Wiring Item Widgets to Collections\n\n**For Paginated Lists:**\n&#96;&#96;&#96;dart\nCategorizedTabBodyView&lt;TaskResponse, TaskData&gt;(\n  // ... pagination setup\n  buildItem: (context, item) =&gt; ItemTaskWidget(\n    task: item,\n    onTap: () =&gt; goToTaskDetail(ref, item.id),\n  ),\n)\n&#96;&#96;&#96;\n\n**For Non-Paginated Lists:**\n&#96;&#96;&#96;dart\nAsyncValueWidget(\n  value: getNewsList(ref),\n  data: (newsList) {\n    final items = newsList?.data ?? [];\n    return ListView.separated(\n      itemCount: items.length,\n      separatorBuilder: (context, index) =&gt; gapH8,\n      itemBuilder: (context, index) =&gt; ItemNewsWidget(\n        imageUrl: items[index].image ?? '',\n        categoryName: items[index].categoryName ?? '',\n        headline: items[index].headline ?? '',\n        date: items[index].date,\n        onTap: () =&gt; goToNewsDetail(ref, items[index].id),\n      ),\n    );\n  },\n)\n&#96;&#96;&#96;\n\n### Reusability Benefits\n\n- ✅ **Consistent UI**: Same item widget used in multiple places (dashboard preview + full list screen)\n- ✅ **Easy testing**: Stateless widgets are easier to test in isolation\n- ✅ **Maintainable**: Changes to item design only need updating in one file\n- ✅ **Clear separation**: Collection handles data/pagination, item handles presentation\n- ✅ **Type-safe**: Domain model ensures compile-time safety\n\n### Example Structure\n\n&#96;&#96;&#96;\nlib/src/feature/task/\n├── data/\n│   └── task_repository.dart\n├── domain/\n│   └── task_response.dart\n└── presentation/\n    ├── task_screen.dart              ← Collection widget\n    ├── controller/\n    │   ├── task_event.dart\n    │   └── task_state.dart\n    └── widget/\n        └── item_task_widget.dart     ← Item widget\n&#96;&#96;&#96;\n\n## Images\n\n- **Network images**: Use &#96;CachedNetworkImage&#96; from &#96;cached_network_image&#96; package\n- **Assets**: Use &#96;Image.asset()&#96; with constants from [assets_constant.dart](mdc:lib/src/constant/assets_constant.dart)\n- **SVG**: Use &#96;SvgPicture.asset()&#96; from &#96;flutter_svg&#96;\n\nAlways provide placeholder and error widgets for network images.\n\n### Image Picker Pattern\n\nFor features that allow users to pick/capture images (e.g., profile pictures):\n\n1. **Use &#96;image_picker&#96; package**: Latest version from pub.dev\n2. **Show bottom sheet with options**: Gallery or Camera (&#96;info_personal_event.dart&#96; lines 22‑68)\n3. **Handle Android MainActivity destruction**: Call &#96;retrieveLostData()&#96; in &#96;initState()&#96; or before showing picker (only on Android with &#96;Platform.isAndroid&#96; checks)\n4. **Store image path in StateProvider**: Create &#96;StateProvider.autoDispose&lt;String?&gt;&#96; in controller for the selected image path\n5. **Display with conditional logic**: Show selected file, cached network image, or placeholder icon\n\n**Example Event Mixin Pattern** (&#96;info_personal_event.dart&#96; lines 38‑100):\n&#96;&#96;&#96;dart\nFuture&lt;void&gt; pickImage(BuildContext context, WidgetRef ref) async {\n  final ImagePicker picker = ImagePicker();\n\n  // Handle Android lost data (MainActivity destruction recovery)\n  // This is a secondary check - primary check happens when screen is mounted\n  // NOTE: retrieveLostData() is only implemented on Android, not on iOS or web\n  if (Platform.isAndroid) {\n    try {\n      final LostDataResponse lostData = await picker.retrieveLostData();\n      if (lostData.isEmpty == false) {\n        final List&lt;XFile&gt;? files = lostData.files;\n        if (files != null &amp;&amp; files.isNotEmpty) {\n          // Lost data found - restore the selected image\n          setProfileImagePath(ref, files.first.path);\n          return;\n        } else if (lostData.exception != null) {\n          // Handle exception from lost data\n          CommonUtils.printAndRecordLog(\n            'Lost image picker exception: ${lostData.exception}',\n            '',\n          );\n        }\n      }\n    } catch (e, st) {\n      // Handle any errors from retrieveLostData\n      CommonUtils.printAndRecordLog(\n        'Error retrieving lost image data: $e',\n        st.toString(),\n      );\n    }\n  }\n\n  if (!context.mounted) return;\n\n  // Show bottom sheet for image source selection\n  final result = await showModalBottomSheet&lt;ImageSource&gt;(\n    context: context,\n    builder: (context) =&gt; SafeArea(\n      child: Column(\n        mainAxisSize: MainAxisSize.min,\n        children: [\n          ListTile(\n            leading: const Icon(Icons.photo_library),\n            title: const Text('Pick from Gallery'),\n            onTap: () =&gt; Navigator.pop(context, ImageSource.gallery),\n          ),\n          ListTile(\n            leading: const Icon(Icons.camera_alt),\n            title: const Text('Take Photo'),\n            onTap: () =&gt; Navigator.pop(context, ImageSource.camera),\n          ),\n        ],\n      ),\n    ),\n  );\n\n  // Pick image and store path in StateProvider\n  if (result != null &amp;&amp; context.mounted) {\n    final XFile? image = await picker.pickImage(source: result);\n    if (image != null) {\n      setProfileImagePath(ref, image.path);\n    }\n  }\n}\n&#96;&#96;&#96;\n\n**Key Points:**\n- ✅ **Android lost data handling**: Always call &#96;retrieveLostData()&#96; on Android to recover from MainActivity destruction\n- ✅ **Platform check**: Use &#96;Platform.isAndroid&#96; before calling &#96;retrieveLostData()&#96; (iOS/web don't support it)\n- ✅ **Error handling**: Wrap &#96;retrieveLostData()&#96; in try-catch and log errors\n- ✅ **Context safety**: Check &#96;context.mounted&#96; before navigation-dependent operations\n- ✅ **StateProvider storage**: Store file path in &#96;StateProvider.autoDispose&lt;String?&gt;&#96; via event mixin setter\n- ✅ **Bottom sheet pattern**: Use &#96;showModalBottomSheet&#96; with &#96;SafeArea&#96; for image source selection\n\n**Example UI Pattern** (&#96;info_personal_screen.dart&#96; lines 110‑168):\n&#96;&#96;&#96;dart\nConsumer(\n  builder: (context, consRef, child) {\n    final profileImagePath = consRef.watch(profileImagePathProvider);\n    \n    return GestureDetector(\n      onTap: () =&gt; pickImage(context, consRef),\n      child: Stack(\n        children: [\n          Container(\n            width: 100.w,\n            height: 100.w,\n            decoration: BoxDecoration(\n              shape: BoxShape.circle,\n              border: Border.all(color: AppColorTheme.blackRock100, width: 2),\n            ),\n            child: ClipOval(\n              child: profileImagePath != null\n                  ? Image.file(File(profileImagePath), fit: BoxFit.cover)\n                  : !CommonUtils.isEmpty(originalImageUrl)\n                      ? CachedNetworkImage(\n                          imageUrl: originalImageUrl,\n                          fit: BoxFit.cover,\n                          placeholder: (context, url) =&gt; const CircularProgressIndicator(),\n                          errorWidget: (context, url, error) =&gt; Image.asset(AssetsConstant.avatar),\n                        )\n                      : Icon(Icons.person, size: 50.w, color: AppColorTheme.blackRock300),\n            ),\n          ),\n          Positioned(\n            bottom: 0,\n            right: 0,\n            child: Container(\n              padding: EdgeInsets.all(4.w),\n              decoration: BoxDecoration(\n                color: AppColorTheme.primary500,\n                shape: BoxShape.circle,\n              ),\n              child: Icon(Icons.camera_alt, size: 20.w, color: AppColorTheme.white),\n            ),\n          ),\n        ],\n      ),\n    );\n  },\n)\n&#96;&#96;&#96;\n\n**Key Points:**\n- ✅ **Wrap in Consumer**: Rebuild when &#96;profileImagePathProvider&#96; changes\n- ✅ **Priority order**: Show selected file → original from API → placeholder icon\n- ✅ **Use &#96;Image.file()&#96;**: Display local file using &#96;File(imagePath)&#96; when path is available\n- ✅ **Use &#96;CachedNetworkImage&#96;**: Display original image from API URL when no local file\n- ✅ **Error handling**: Provide fallback placeholder for network image errors\n- ✅ **Visual feedback**: Add camera icon overlay to indicate image is tappable\n\n**File Upload Integration:**\n- The selected file path is stored in &#96;StateProvider&#96; and passed to controller on form submission\n- Controller conditionally uploads file using &#96;FormData&#96; with &#96;MultipartFile&#96; (see [File Upload Pattern](mdc:.cursor/rules/riverpod-patterns.mdc) in riverpod-patterns.mdc)\n\n**iOS Permissions** (&#96;ios/Runner/Info.plist&#96;):\n&#96;&#96;&#96;xml\n&lt;key&gt;NSPhotoLibraryUsageDescription&lt;/key&gt;\n&lt;string&gt;We need access to your photo library to update your profile picture&lt;/string&gt;\n&lt;key&gt;NSCameraUsageDescription&lt;/key&gt;\n&lt;string&gt;We need access to your camera to take a profile picture&lt;/string&gt;\n&#96;&#96;&#96;\n\n## Forms\n\nUse &#96;flutter_form_builder&#96; for form handling:\n- Custom form fields in &#96;lib/src/common_widget/form/&#96;\n- Validation with &#96;form_builder_validators&#96;\n- Localized error messages\n\n### Custom Form Fields\n\n- Always use the shared form widgets instead of creating ad‑hoc fields:\n  - &#96;CustomDropdownFormField&#96; for any dropdown (&#96;register_screen.dart&#96; lines 155‑170).\n  - &#96;CustomTextFormField&#96; for text/textarea inputs (&#96;help_desk_screen.dart&#96; lines 96‑137).\n  - &#96;CustomDatePickerField&#96; for date selection (&#96;register_screen.dart&#96; lines 195‑205).\n- These widgets already apply spacing, theming, and validation styles. Pass localization titles/hints (e.g. &#96;*${loc.category}&#96;) and surface validation errors via their &#96;errorValidation&#96; parameter for dropdowns/date pickers or built‑in validators for text fields.\n\n### State Management for Form Inputs\n\n- When a form needs to reuse dropdown selections, date picker values, or other form inputs (e.g. submit to repository), declare &#96;StateProvider.autoDispose&#96; fields in the feature controller file. Examples:\n  - &#96;help_desk_controller.dart&#96; lines 6‑17 create &#96;helpDeskCategoryProvider&#96;, &#96;helpDeskSubCategoryProvider&#96;, &#96;helpDeskShowErrorsProvider&#96;.\n  - &#96;register_controller.dart&#96; line 8 creates &#96;dateOfBirthProvider&#96; for date selection.\n- Read these providers inside repositories instead of passing raw values through every method. Example: &#96;help_desk_repository.dart&#96; lines 19‑20 read the selected categories before calling &#96;/api/v1/sendfeedback&#96;.\n- Expose helper getters in the feature &#96;*_state.dart&#96; mixin and setters in the feature &#96;*_event.dart&#96; so UI widgets can update the providers without direct &#96;ref.watch&#96;. Example: &#96;register_state.dart&#96; line 14 exposes &#96;getDateOfBirth()&#96; and &#96;register_event.dart&#96; line 90 exposes &#96;setDateOfBirth()&#96;.\n\n### Form-Driven Filter Submission Pattern\n\nWhen filters should only apply after user taps a submit button (not on every dropdown change), use a **two-tier StateProvider pattern**:\n\n**1. Local StateProviders** (in screen/widget file):\n- Defined in the screen or dialog widget file (e.g., &#96;newsletter_screen.dart&#96;, &#96;task_filter_dialog.dart&#96;)\n- Used for immediate UI updates when dropdowns change\n- **NOT** used by repository for API calls\n- Example: &#96;localCategoryIdProvider&#96;, &#96;localTaskSourceProvider&#96;\n\n**2. Global StateProviders** (in controller file):\n- Defined in the feature controller file (e.g., &#96;newsletter_controller.dart&#96;, &#96;task_controller.dart&#96;)\n- Used by repository for API filtering\n- Only updated when submit button is pressed\n- Example: &#96;newsletterCategoryIdProvider&#96;, &#96;taskSourceProvider&#96;\n\n**Pattern Implementation:**\n\n**Step 1: Define Local Providers** (in screen/widget file):\n&#96;&#96;&#96;dart\n// Local StateProviders for form field selections (stored locally, not in global providers)\n// These values are only updated when the search button is pressed\n// They are used to immediately update the UI when dropdowns change\nfinal localCategoryIdProvider = StateProvider.autoDispose&lt;int&gt;((ref) =&gt; 0);\nfinal localTaskSourceProvider = StateProvider.autoDispose&lt;String?&gt;((ref) =&gt; null);\n&#96;&#96;&#96;\n\n**Step 2: Define Global Providers** (in controller file):\n&#96;&#96;&#96;dart\n// Global StateProviders used by repository for API filtering\nfinal newsletterCategoryIdProvider = StateProvider.autoDispose&lt;int&gt;((ref) =&gt; 0);\nfinal taskSourceProvider = StateProvider.autoDispose&lt;String?&gt;((ref) =&gt; null);\n&#96;&#96;&#96;\n\n**Step 3: Add Local Provider Getters/Setters** (in state/event mixins):\n&#96;&#96;&#96;dart\n// In *_state.dart mixin\nmixin class TaskState {\n  String? getLocalSelectedTaskSource(WidgetRef ref) =&gt;\n      ref.watch(localTaskSourceProvider);\n}\n\n// In *_event.dart mixin\nmixin class TaskEvent {\n  void setLocalSelectedTaskSource(WidgetRef ref, String? source) {\n    ref.read(localTaskSourceProvider.notifier).state = source;\n  }\n}\n&#96;&#96;&#96;\n\n**Step 4: Use Local Providers in UI** (dropdowns update local providers):\n&#96;&#96;&#96;dart\nCustomDropdownFormField&lt;ItemDropdown&gt;(\n  title: 'Source'.hardcoded,\n  hintText: 'Select source'.hardcoded,\n  items: items,\n  valueId: getLocalSelectedTaskSource(consRef), // Read from local provider\n  onChanged: (item) {\n    setLocalSelectedTaskSource(consRef, item?.id); // Update local provider immediately\n  },\n)\n&#96;&#96;&#96;\n\n**Step 5: Submit Handler** (copy local → global, read textfield from formKey):\n&#96;&#96;&#96;dart\nFuture&lt;void&gt; submitFilter(\n  WidgetRef ref,\n  GlobalKey&lt;FormBuilderState&gt; formKey,\n) async {\n  FocusManager.instance.primaryFocus?.unfocus();\n  formKey.currentState?.save();\n  final values = formKey.currentState!.value;\n  \n  // Read textfield value from formKey\n  final keywordValue = values[TaskEvent.keyKeyword] as String?;\n  \n  // Read dropdown values from local providers\n  final taskState = TaskState();\n  final source = taskState.getLocalSelectedTaskSource(ref);\n  final departmentId = taskState.getLocalSelectedTaskDepartmentId(ref);\n  \n  // Copy local providers to global providers (used by repository)\n  ref.read(taskKeywordProvider.notifier).state = keywordValue;\n  ref.read(taskSourceProvider.notifier).state = source;\n  ref.read(taskDepartmentIdProvider.notifier).state = departmentId;\n  \n  // Invalidate to trigger new API call with filters\n  ref.invalidate(getTaskListProvider(page: 1));\n}\n&#96;&#96;&#96;\n\n**Key Points:**\n- ✅ **Local providers**: Update immediately on dropdown change for UI feedback\n- ✅ **Global providers**: Only updated on submit, used by repository for API calls\n- ✅ **TextField values**: Read from &#96;formKey.currentState!.value&#96; on submit\n- ✅ **Dropdown values**: Read from local providers on submit, then copy to global\n- ✅ **Separation of concerns**: UI state (local) vs API state (global)\n- ✅ **No premature API calls**: Filters only apply when user explicitly submits\n\n**Reference Examples:**\n- &#96;newsletter_screen.dart&#96; lines 25‑27: Local providers definition\n- &#96;newsletter_event.dart&#96; lines 15‑25: Local provider setters\n- &#96;newsletter_event.dart&#96; lines 27‑48: Submit handler pattern\n- &#96;task_filter_dialog.dart&#96;: Complete implementation example\n\n### Pre-filling Forms with API Data\n\nWhen a form needs to be pre-filled with data from an API:\n\n1. **Wrap form in &#96;AsyncValueWidget&#96;**: Load the data first, then render the form once data is available (&#96;info_personal_screen.dart&#96; lines 87‑292).\n2. **Set &#96;initialValue&#96; on FormBuilder fields**: Use the fetched data to pre-fill text fields (&#96;info_personal_screen.dart&#96; lines 182‑189, 192‑202, 245‑255, 258‑267).\n3. **Pre-fill StateProviders in repository**: For dropdown/date picker fields managed by &#96;StateProvider&#96;, set their values **in the repository** immediately after parsing the API response (&#96;info_personal_repository.dart&#96; lines 29‑31). This ensures the state is ready before the UI renders. Make sure StateProviders is auto disposed\n4. **Access values via form key in events**: Read FormBuilder field values using &#96;formKey.currentState!.value['keyName']&#96; in event mixins when submitting (&#96;info_personal_event.dart&#96; lines 70‑73, 96‑110).\n\n**Example Repository Pattern:**\n&#96;&#96;&#96;dart\n@riverpod\nFuture&lt;CustomerDetailResponse?&gt; getCustomerDetail(Ref ref) async {\n  // ... API call\n  final result = CustomerDetailResponse.fromJson(response.data);\n  \n  // ✅ Pre-fill StateProviders immediately after parsing\n  ref.watch(genderProvider.notifier).state = result.data?.customer?.gender;\n  ref.watch(dateOfBirthProvider.notifier).state = result.data?.customer?.dateOfBirth;\n  \n  return result;\n}\n&#96;&#96;&#96;\n\n**Example UI Pattern:**\n&#96;&#96;&#96;dart\nAsyncValueWidget(\n  value: getCustomerDetail(ref), // Fetch data first\n  data: (customerDetail) {\n    final user = customerDetail?.data?.user;\n    return FormBuilder(\n      key: _formKey,\n      child: Column(\n        children: [\n          CustomTextFormField(\n            initialValue: user?.fullname, // Pre-fill from API\n            name: keyFullName,\n            // ...\n          ),\n          Consumer(\n            builder: (context, consRef, child) {\n              return CustomDropdownFormField(\n                valueId: getGender(consRef), // Already set in repository\n                // ...\n              );\n            },\n          ),\n        ],\n      ),\n    );\n  },\n)\n&#96;&#96;&#96;\n\n### Rebuilding Form Widgets\n\n- Wrap dropdowns, date pickers, and buttons that depend on provider state in a &#96;Consumer&#96; (or use a &#96;ConsumerWidget&#96;) so they rebuild correctly and only rebuild necessary part when the providers change. See:\n  - &#96;register_screen.dart&#96; lines 155‑170 for dropdown rebuild.\n  - &#96;register_screen.dart&#96; lines 195‑205 for date picker rebuild with state management.\n  - &#96;register_screen.dart&#96; lines 228‑247 for buttons that reflect controller loading state.\n  - &#96;info_personal_screen.dart&#96; lines 205‑224, 227‑242, 270‑284 for comprehensive form rebuild patterns.\n- Apply the same pattern for other features (e.g. Help Desk form) so validation and button states update predictably.\n\n**Date Picker Pattern:**\n&#96;&#96;&#96;dart\nConsumer(\n  builder: (context, consRef, child) {\n    return CustomDatePickerField(\n      initialValue: getDateOfBirth(consRef), // From state mixin\n      title: '*${loc.dob}',\n      onSetDateResult: (value) {\n        setDateOfBirth(consRef, value ?? ''); // From event mixin\n      },\n      errorValidation: showErrors &amp;&amp; getDateOfBirth(consRef) == null\n          ? loc.please_complete\n          : null,\n    );\n  },\n)\n&#96;&#96;&#96;\n\n### Form Validation Pattern\n\n**Validation logic must be placed in event mixins** (&#96;*_event.dart&#96;), not in the UI layer. Follow this pattern:\n\n**In Event Mixin** (&#96;help_desk_event.dart&#96; lines 20‑51):\n&#96;&#96;&#96;dart\nFuture&lt;void&gt; submitHelpDesk(\n  WidgetRef ref, {\n  required GlobalKey&lt;FormBuilderState&gt; formKey,\n}) async {\n  // 1. Unfocus keyboard first\n  FocusManager.instance.primaryFocus?.unfocus();\n  \n  // 2. Set show errors flag to trigger validation display\n  ref.read(helpDeskShowErrorsProvider.notifier).state = true;\n  \n  // 3. Validate form builder fields\n  if (formKey.currentState?.saveAndValidate() ?? false) {\n    try {\n      // 4. Extract form values\n      final message = formKey.currentState!.value['message'] as String?;\n      \n      // 5. Read StateProvider values (for dropdowns)\n      final firstCategory = ref.read(helpDeskCategoryProvider);\n      final secondCategory = ref.read(helpDeskSubCategoryProvider);\n      \n      // 6. Additional validation: Check all required fields\n      if (message == null ||\n          message.isEmpty ||\n          firstCategory == null ||\n          secondCategory == null) {\n        return; // Stop if validation fails\n      }\n      \n      // 7. Proceed with API call\n      await ref.watch(helpDeskControllerProvider.notifier)\n          .sendFeedback(message: message);\n      \n      // 8. Reset show errors flag on success\n      ref.read(helpDeskShowErrorsProvider.notifier).state = false;\n    } catch (e, st) {\n      CommonUtils.printAndRecordLog(e, st.toString());\n      rethrow;\n    }\n  }\n}\n&#96;&#96;&#96;\n\n**In UI Layer** (&#96;help_desk_screen.dart&#96; lines 113‑115):\n- Conditionally display validation errors based on &#96;showErrors&#96; flag and field value:\n&#96;&#96;&#96;dart\nCustomDropdownFormField(\n  // ... other properties\n  errorValidation: showErrors &amp;&amp; selectedSubCategory == null\n      ? loc.please_complete\n      : null,\n)\n&#96;&#96;&#96;\n\n**Key Points:**\n- Always unfocus keyboard before validation: &#96;FocusManager.instance.primaryFocus?.unfocus();&#96;\n- Use a &#96;StateProvider.autoDispose&lt;bool&gt;&#96; (e.g., &#96;helpDeskShowErrorsProvider&#96;) to control when validation errors are displayed\n- Set &#96;showErrors = true&#96; before validation, reset to &#96;false&#96; on successful submission\n- Validate both FormBuilder fields (&#96;saveAndValidate()&#96;) AND StateProvider values (dropdown selections)\n- Display errors conditionally: &#96;errorValidation: showErrors &amp;&amp; fieldIsInvalid ? errorMessage : null&#96;\n- Clear errors when user interacts with fields: &#96;setShowHelpDeskErrors(ref, false)&#96; in &#96;onChanged&#96; callbacks\n\n## Pull-to-Refresh Pattern\n\nUse the [&#96;any_refreshable_widget&#96;](https://pub.dev/packages/any_refreshable_widget) package (published by logique.co.id) for implementing pull-to-refresh functionality.\n\n### Setup\n\n**1. Add dependency** (&#96;pubspec.yaml&#96;):\n&#96;&#96;&#96;yaml\ndependencies:\n  any_refreshable_widget: ^0.2.0\n&#96;&#96;&#96;\n\n**2. Create refresh method in event mixin** (&#96;*_event.dart&#96;):\n&#96;&#96;&#96;dart\nFuture&lt;void&gt; refreshHome(WidgetRef ref) async {\n  await Future.wait([\n    ref.refresh(getBannerListProvider.future),\n    ref.refresh(getNewsListProvider.future),\n    ref.refresh(getEventListProvider.future),\n  ]);\n}\n&#96;&#96;&#96;\n\n**Key Points:**\n- Use &#96;ref.refresh(provider.future)&#96; instead of &#96;ref.invalidate()&#96; for better control\n- Use &#96;Future.wait([...])&#96; to refresh multiple providers concurrently\n- Method must return &#96;Future&lt;void&gt;&#96; for async operation\n- Place in event mixin, not directly in UI\n\n**3. Wrap screen body with &#96;AnyRefreshableWidget.single&#96;** (&#96;*_screen.dart&#96;):\n&#96;&#96;&#96;dart\nimport 'package:any_refreshable_widget/any_refreshable_widget.dart';\n\nreturn Scaffold(\n  body: AnyRefreshableWidget.single(\n    onRefresh: () async =&gt; await refreshHome(ref),\n    refreshColor: AppColorTheme.primary500,\n    backgroundColor: AppColorTheme.white,\n    builder: (context, isLoading, error) {\n      return SingleChildScrollView(\n        child: Column(\n          children: [\n            // Your content here\n          ],\n        ),\n      );\n    },\n  ),\n);\n&#96;&#96;&#96;\n\n### Layout Structure Requirements\n\n**IMPORTANT**: When using &#96;AnyRefreshableWidget&#96;, the builder must return a scrollable widget structure:\n\n❌ **Wrong** - Will cause \"RenderFlex unbounded height\" error:\n&#96;&#96;&#96;dart\nAnyRefreshableWidget.single(\n  builder: (context, isLoading, error) {\n    return Column(              // ❌ Column with Expanded\n      children: [\n        SizedBox(height: 200),\n        Expanded(               // ❌ Expanded in scrollable context\n          child: ListView(...), // ❌ Nested scrollable\n        ),\n      ],\n    );\n  },\n)\n&#96;&#96;&#96;\n\n✅ **Correct** - Use &#96;SingleChildScrollView&#96; with &#96;Column&#96;:\n&#96;&#96;&#96;dart\nAnyRefreshableWidget.single(\n  builder: (context, isLoading, error) {\n    return SingleChildScrollView(  // ✅ Single scrollable parent\n      child: Column(                // ✅ Column without Expanded\n        children: [\n          SizedBox(height: 200),\n          Padding(                  // ✅ Use Padding instead of ListView\n            padding: EdgeInsets.symmetric(horizontal: 16.w),\n            child: Column(\n              children: [\n                // All content here\n              ],\n            ),\n          ),\n        ],\n      ),\n    );\n  },\n)\n&#96;&#96;&#96;\n\n### Complete Example Pattern\n\nReference: &#96;home_subscreen.dart&#96; lines 40-116\n\n&#96;&#96;&#96;dart\nclass HomeSubscreen extends ConsumerWidget with HomeEvent, HomeState {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    return Scaffold(\n      body: AnyRefreshableWidget.single(\n        onRefresh: () async =&gt; await refreshHome(ref), // From event mixin\n        refreshColor: AppColorTheme.primary500,\n        backgroundColor: AppColorTheme.white,\n        builder: (context, isLoading, error) {\n          return Stack(\n            children: [\n              SingleChildScrollView(\n                child: Column(\n                  children: [\n                    // Fixed height sections\n                    SizedBox(height: 300, child: CarouselSection()),\n                    \n                    // Content sections\n                    Padding(\n                      padding: EdgeInsets.symmetric(horizontal: 16.w),\n                      child: Column(\n                        children: [\n                          MenuWidget(),\n                          NewsListWidget(),\n                          EventListWidget(),\n                        ],\n                      ),\n                    ),\n                  ],\n                ),\n              ),\n              \n              // Optional: Floating elements\n              Positioned(\n                top: 100,\n                child: FloatingCard(),\n              ),\n            ],\n          );\n        },\n      ),\n    );\n  }\n}\n&#96;&#96;&#96;\n\n### Key Benefits\n\n- ✅ **Concurrent refresh**: Multiple providers refresh simultaneously\n- ✅ **Themed indicator**: Matches app design system\n- ✅ **Smooth UX**: Proper loading states and error handling\n- ✅ **Event mixin pattern**: Follows project architecture\n- ✅ **Single scrollable**: Avoids layout conflicts\n\n## Conditional UI Rendering Based on Authentication\n\nUse &#96;StreamBuilder&#96; with &#96;getAppUserStream&#96; to conditionally show/hide UI sections based on authentication state.\n\n### Pattern\n\n**In Home Screen** (&#96;home_subscreen.dart&#96;):\n&#96;&#96;&#96;dart\nConsumer(\n  builder: (context, consRef, child) {\n    return StreamBuilder(\n      stream: getAppUserStream(consRef),\n      builder: (context, snapshot) {\n        if (snapshot.hasData &amp;&amp; snapshot.data != null) {\n          return Column(\n            children: [gapH16, _buildReportList(loc)],\n          );\n        }\n        return const SizedBox.shrink();\n      },\n    );\n  },\n)\n&#96;&#96;&#96;\n\n**Key Points:**\n- ✅ **Use &#96;StreamBuilder&#96;**: Provides reactive updates when auth state changes\n- ✅ **Check both &#96;hasData&#96; and &#96;data != null&#96;**: Ensures data exists and is not null\n- ✅ **Return &#96;SizedBox.shrink()&#96;**: When condition is false, return empty widget instead of null\n- ✅ **Wrap in &#96;Consumer&#96;**: If accessing Riverpod providers inside the builder\n\n## Horizontal Scrolling Lists\n\nUse &#96;ListView.separated&#96; with &#96;Axis.horizontal&#96; for horizontal scrolling lists with spacing between items.\n\n### Pattern\n\n&#96;&#96;&#96;dart\nSizedBox(\n  height: MediaQuery.sizeOf(context).height * 0.3, // Fixed height\n  child: ListView.separated(\n    scrollDirection: Axis.horizontal,\n    itemCount: items.length,\n    separatorBuilder: (context, index) =&gt; gapW16, // Spacing between items\n    itemBuilder: (context, index) {\n      final item = items[index];\n      return SizedBox(\n        width: MediaQuery.sizeOf(context).width * 0.7, // Item width\n        child: ItemWidget(\n          // ... item properties\n        ),\n      );\n    },\n  ),\n)\n&#96;&#96;&#96;\n\n**Key Points:**\n- ✅ **Use &#96;ListView.separated&#96;**: Better than &#96;ListView.builder&#96; when you need spacing\n- ✅ **Set fixed height**: Required for horizontal &#96;ListView&#96;\n- ✅ **Set item width**: Use &#96;SizedBox&#96; with percentage-based width (e.g., 70% of screen width)\n- ✅ **Use gap constants**: Use &#96;gapW16&#96;, &#96;gapW8&#96;, etc. for consistent spacing\n\n## Widget Extraction for Large Screens\n\nWhen screens become too large (&gt;300 lines), extract complex widgets into separate files in the &#96;widget/&#96; folder.\n\n### Pattern\n\n**Before** (large screen file):\n&#96;&#96;&#96;dart\nclass NewsletterScreen extends ConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    return Scaffold(\n      body: Column(\n        children: [\n          _buildFilterSection(), // 100+ lines\n          _buildTableSection(), // 200+ lines\n        ],\n      ),\n    );\n  }\n}\n&#96;&#96;&#96;\n\n**After** (extracted widgets):\n&#96;&#96;&#96;dart\n// newsletter_screen.dart\nclass NewsletterScreen extends ConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    return Scaffold(\n      body: Column(\n        children: [\n          NewsletterFilterSection(),\n          NewsletterTableSection(),\n        ],\n      ),\n    );\n  }\n}\n\n// widget/newsletter_filter_section.dart\nclass NewsletterFilterSection extends StatelessWidget {\n  // Extracted filter widget\n}\n\n// widget/newsletter_table_section.dart\nclass NewsletterTableSection extends StatelessWidget {\n  // Extracted table widget\n}\n&#96;&#96;&#96;\n\n**Key Points:**\n- ✅ **Extract when &gt;300 lines**: Keep screen files focused and maintainable\n- ✅ **Place in &#96;widget/&#96; folder**: Feature-specific widgets go in &#96;feature/*/presentation/widget/&#96;\n- ✅ **Use descriptive names**: Widget names should clearly indicate their purpose\n- ✅ **Add comments**: Document complex widgets with class-level comments\n\n## Accordion-Style Expandable Sections\n\nUse &#96;AnimatedAlign&#96; with &#96;heightFactor&#96; and &#96;AnimatedRotation&#96; for accordion-style expandable/collapsible sections.\n\n### Pattern\n\n&#96;&#96;&#96;dart\nfinal isExpandedProvider = StateProvider.autoDispose&lt;bool&gt;((ref) =&gt; true);\n\n// In build method\nContainer(\n  child: Column(\n    children: [\n      InkWell(\n        onTap: () =&gt; toggleFilterVisibility(ref),\n        child: Row(\n          children: [\n            Text('Filters'),\n            const Spacer(),\n            AnimatedRotation(\n              turns: isExpanded ? 0 : -0.25,\n              duration: const Duration(milliseconds: 250),\n              child: Icon(Icons.keyboard_arrow_down),\n            ),\n          ],\n        ),\n      ),\n      ClipRect(\n        child: AnimatedAlign(\n          alignment: Alignment.topCenter,\n          duration: const Duration(milliseconds: 300),\n          curve: Curves.easeInOut,\n          heightFactor: isExpanded ? 1 : 0, // Controls expansion\n          child: FormBuilder(\n            // Form content here\n          ),\n        ),\n      ),\n    ],\n  ),\n)\n&#96;&#96;&#96;\n\n**Key Points:**\n- ✅ **Use &#96;AnimatedAlign&#96; with &#96;heightFactor&#96;**: Smoothly expands/collapses content\n- ✅ **Wrap in &#96;ClipRect&#96;**: Prevents overflow during animation\n- ✅ **Use &#96;AnimatedRotation&#96;**: Rotates arrow icon to indicate state\n- ✅ **StateProvider for state**: Use &#96;StateProvider.autoDispose&lt;bool&gt;&#96; to manage expanded state\n- ✅ **Smooth animations**: Use &#96;Curves.easeInOut&#96; for natural feel\n\n## Table Display with Synchronized Scrolling\n\nFor tables with horizontal scrolling, use separate scroll controllers and &#96;NotificationListener&#96; to synchronize header and body scrolling.\n\n### Pattern\n\n&#96;&#96;&#96;dart\nfinal headerScrollController = ScrollController();\nfinal bodyScrollController = ScrollController();\n\n// Listen to body scroll and sync header\nNotificationListener&lt;ScrollNotification&gt;(\n  onNotification: (notification) {\n    if (notification is ScrollUpdateNotification) {\n      headerScrollController.jumpTo(bodyScrollController.offset);\n    }\n    return false;\n  },\n  child: SingleChildScrollView(\n    controller: bodyScrollController,\n    scrollDirection: Axis.horizontal,\n    child: Table(\n      // Table body\n    ),\n  ),\n)\n\n// Header with separate controller\nSingleChildScrollView(\n  controller: headerScrollController,\n  scrollDirection: Axis.horizontal,\n  child: TableHeader(),\n)\n&#96;&#96;&#96;\n\n**Key Points:**\n- ✅ **Separate controllers**: One for header, one for body\n- ✅ **Use &#96;NotificationListener&#96;**: Captures scroll events from body\n- ✅ **Use &#96;jumpTo&#96;**: Synchronizes header position with body\n- ✅ **Handle &#96;ScrollUpdateNotification&#96;**: Only sync on scroll updates, not all notifications\n\n## AppBar Patterns\n\n### Platform-Specific Back Button\n\nAlways use platform-specific back icons in AppBar leading:\n\n&#96;&#96;&#96;dart\nAppBar(\n  backgroundColor: AppColorTheme.primary500,\n  leading: IconButton(\n    onPressed: () =&gt; context.pop(),\n    icon: Icon(\n      Platform.isIOS ? Icons.arrow_back_ios : Icons.arrow_back,\n      color: AppColorTheme.white,\n    ),\n  ),\n  title: Text(\n    loc.personal_info,\n    style: AppTextTheme.semiBoldBase.copyWith(color: AppColorTheme.white),\n  ),\n)\n&#96;&#96;&#96;\n\n- iOS: Use &#96;Icons.arrow_back_ios&#96;\n- Android: Use &#96;Icons.arrow_back&#96;\n- Import &#96;dart:io&#96; to access &#96;Platform&#96;\n- Always apply theming colors consistently (e.g., &#96;AppColorTheme.white&#96; for icons and title text on primary background)\n"
}
```
User decision: **accepted**

Status: **completed**


</details>
</tool-use>

---

<tool-use data-tool-type="unknown" data-tool-name="apply_patch">
<details>
<summary>Tool use: **apply_patch**</summary>


Parameters:

```json
{
  "relativeWorkspacePath": "/Users/cirimin/Logique/Project Starter/project-starter/src/__brick__/{{project_name}}/.cursor/rules/project-structure.mdc"
}
```
Additional data:

```json
{
  "reasonForAcceptReject": {
    "type": "restrictedFile"
  },
  "codeblockId": "fa050701-2a7d-43cb-931f-7700b45eccec",
  "codeblock": {
    "uri": {
      "scheme": "file",
      "authority": "",
      "path": "/Users/cirimin/Logique/Project Starter/project-starter/src/__brick__/{{project_name}}/.cursor/rules/project-structure.mdc",
      "query": "",
      "fragment": "",
      "_formatted": "file:///Users/cirimin/Logique/Project%20Starter/project-starter/src/__brick__/%7B%7Bproject_name%7D%7D/.cursor/rules/project-structure.mdc",
      "_fsPath": "/Users/cirimin/Logique/Project Starter/project-starter/src/__brick__/{{project_name}}/.cursor/rules/project-structure.mdc"
    },
    "codeblockId": "fa050701-2a7d-43cb-931f-7700b45eccec",
    "codeBlockIdx": 0,
    "content": "---\nalwaysApply: true\n---\n# {{app_name}} Project Structure\n\nThis is a Flutter mobile application built with a feature-based architecture.\n\n## Project Overview\n\n- **Framework**: Flutter 3.38.0+\n- **Language**: Dart 3.8.1+\n- **State Management**: Riverpod 3.0.3 (with code generation)\n- **Routing**: GoRouter 17.0.0\n- **Local Database**: Sembast 3.8.5+2\n- **HTTP Client**: Dio 5.9.0\n- **Responsive Design**: Flutter ScreenUtil 5.9.3\n\n## Directory Structure\n\nThe main source code is located in &#96;lib/src/&#96;:\n\n- **&#96;app.dart&#96;**: Main application widget with MaterialApp.router setup\n- **&#96;common_widget/&#96;**: Reusable widgets used across features\n- **&#96;constant/&#96;**: App constants (assets, error messages, etc.)\n- **&#96;core/&#96;**: Core mixins and utilities (router_mixin, startup_mixin, etc.)\n- **&#96;feature/&#96;**: Feature modules organized by domain\n- **&#96;localization/&#96;**: Localization files and providers (en, id)\n- **&#96;routing/&#96;**: GoRouter configuration and route definitions\n- **&#96;service/&#96;**: Services (Firebase, notifications)\n- **&#96;theme/&#96;**: App theming (colors, text styles, sizes)\n- **&#96;utils/&#96;**: Utility functions and configurations\n\n## Feature Module Structure\n\nEach feature in &#96;lib/src/feature/&#96; follows this structure:\n\n&#96;&#96;&#96;\nfeature_name/\n  ├── data/\n  │   ├── feature_repository.dart        # Repository implementation\n  │   └── feature_repository.g.dart      # Generated Riverpod providers\n  ├── domain/\n  │   └── *.dart                         # Domain models/entities\n  └── presentation/\n      ├── feature_screen.dart            # Main screen widget\n      ├── feature_subscreen.dart         # Sub-screen widgets\n      ├── controller/\n      │   ├── feature_event.dart         # Navigation/action mixins\n      │   └── feature_state.dart         # State management mixins\n      └── widget/                        # Feature-specific widgets\n&#96;&#96;&#96;\n\n## Entry Points\n\n- **&#96;main_dev.dart&#96;**: Development flavor entry point\n- **&#96;main_stg.dart&#96;**: Staging flavor entry point\n- **&#96;main_prod.dart&#96;**: Production flavor entry point\n- **&#96;initializer.dart&#96;**: App initialization logic\n- **&#96;flavor.dart&#96;**: Flavor configuration\n\n## Flavors\n\nThe app supports three flavors:\n- **dev**: Development environment (&#96;{{app_id}}.dev&#96;)\n- **stg**: Staging environment (&#96;{{app_id}}.stg&#96;)\n- **prod**: Production environment (&#96;{{app_id}}&#96;)\n\nFlavor configuration is in [pubspec.yaml](mdc:pubspec.yaml) under &#96;flavorizr&#96;.\n\n## Key Files\n\n- [app.dart](mdc:lib/src/app.dart): Main app widget with router and localization setup\n- [app_router.dart](mdc:lib/src/routing/app_router.dart): GoRouter configuration\n- [app_startup.dart](mdc:lib/src/routing/app_startup.dart): App initialization\n- [pubspec.yaml](mdc:pubspec.yaml): Dependencies and project configuration\n",
    "languageId": "markdown"
  }
}
```
Result:

```json
{
  "diff": {
    "chunks": [
      {
        "diffString": "  alwaysApply: true\n  ---\n- # MM2100 Mobile Project Structure\n+ # {{app_name}} Project Structure\n  \n  This is a Flutter mobile application built with a feature-based architecture.",
        "oldStart": 2,
        "newStart": 2,
        "oldLines": 5,
        "newLines": 5,
        "linesRemoved": 1,
        "linesAdded": 1
      },
      {
        "diffString": "  \n  The app supports three flavors:\n- - **dev**: Development environment (&#96;id.logique.mm2100.dev&#96;)\n- - **stg**: Staging environment (&#96;id.logique.mm2100.stg&#96;)\n- - **prod**: Production environment (&#96;id.logique.mm2100&#96;)\n+ - **dev**: Development environment (&#96;{{app_id}}.dev&#96;)\n+ - **stg**: Staging environment (&#96;{{app_id}}.stg&#96;)\n+ - **prod**: Production environment (&#96;{{app_id}}&#96;)\n  \n  Flavor configuration is in [pubspec.yaml](mdc:pubspec.yaml) under &#96;flavorizr&#96;.",
        "oldStart": 62,
        "newStart": 62,
        "oldLines": 7,
        "newLines": 7,
        "linesRemoved": 3,
        "linesAdded": 3
      }
    ],
    "editor": "EDITOR_AI"
  },
  "shouldAutoFixLints": true,
  "resultForModel": "Success. Updated the following files:\nM /Users/cirimin/Logique/Project Starter/project-starter/src/__brick__/{{project_name}}/.cursor/rules/project-structure.mdc",
  "contentsAfterEdit": "---\nalwaysApply: true\n---\n# {{app_name}} Project Structure\n\nThis is a Flutter mobile application built with a feature-based architecture.\n\n## Project Overview\n\n- **Framework**: Flutter 3.38.0+\n- **Language**: Dart 3.8.1+\n- **State Management**: Riverpod 3.0.3 (with code generation)\n- **Routing**: GoRouter 17.0.0\n- **Local Database**: Sembast 3.8.5+2\n- **HTTP Client**: Dio 5.9.0\n- **Responsive Design**: Flutter ScreenUtil 5.9.3\n\n## Directory Structure\n\nThe main source code is located in &#96;lib/src/&#96;:\n\n- **&#96;app.dart&#96;**: Main application widget with MaterialApp.router setup\n- **&#96;common_widget/&#96;**: Reusable widgets used across features\n- **&#96;constant/&#96;**: App constants (assets, error messages, etc.)\n- **&#96;core/&#96;**: Core mixins and utilities (router_mixin, startup_mixin, etc.)\n- **&#96;feature/&#96;**: Feature modules organized by domain\n- **&#96;localization/&#96;**: Localization files and providers (en, id)\n- **&#96;routing/&#96;**: GoRouter configuration and route definitions\n- **&#96;service/&#96;**: Services (Firebase, notifications)\n- **&#96;theme/&#96;**: App theming (colors, text styles, sizes)\n- **&#96;utils/&#96;**: Utility functions and configurations\n\n## Feature Module Structure\n\nEach feature in &#96;lib/src/feature/&#96; follows this structure:\n\n&#96;&#96;&#96;\nfeature_name/\n  ├── data/\n  │   ├── feature_repository.dart        # Repository implementation\n  │   └── feature_repository.g.dart      # Generated Riverpod providers\n  ├── domain/\n  │   └── *.dart                         # Domain models/entities\n  └── presentation/\n      ├── feature_screen.dart            # Main screen widget\n      ├── feature_subscreen.dart         # Sub-screen widgets\n      ├── controller/\n      │   ├── feature_event.dart         # Navigation/action mixins\n      │   └── feature_state.dart         # State management mixins\n      └── widget/                        # Feature-specific widgets\n&#96;&#96;&#96;\n\n## Entry Points\n\n- **&#96;main_dev.dart&#96;**: Development flavor entry point\n- **&#96;main_stg.dart&#96;**: Staging flavor entry point\n- **&#96;main_prod.dart&#96;**: Production flavor entry point\n- **&#96;initializer.dart&#96;**: App initialization logic\n- **&#96;flavor.dart&#96;**: Flavor configuration\n\n## Flavors\n\nThe app supports three flavors:\n- **dev**: Development environment (&#96;{{app_id}}.dev&#96;)\n- **stg**: Staging environment (&#96;{{app_id}}.stg&#96;)\n- **prod**: Production environment (&#96;{{app_id}}&#96;)\n\nFlavor configuration is in [pubspec.yaml](mdc:pubspec.yaml) under &#96;flavorizr&#96;.\n\n## Key Files\n\n- [app.dart](mdc:lib/src/app.dart): Main app widget with router and localization setup\n- [app_router.dart](mdc:lib/src/routing/app_router.dart): GoRouter configuration\n- [app_startup.dart](mdc:lib/src/routing/app_startup.dart): App initialization\n- [pubspec.yaml](mdc:pubspec.yaml): Dependencies and project configuration\n"
}
```
User decision: **accepted**

Status: **completed**


</details>
</tool-use>

---

I’ve updated the brick `.cursor` rules to use Mason variables where they referenced your concrete project:

- **`dart-conventions.mdc`**: Replaced the import with `package:{{project_name}}/src/theme/app_color_theme.dart`.
- **`flutter-ui-patterns.mdc`**: Replaced the import with `package:{{project_name}}/src/feature/task/presentation/widget/item_task_widget.dart`.
- **`project-structure.mdc`**:  
  - Changed the title to `{{app_name}} Project Structure`.  
  - Changed flavor bundle IDs to use `{{app_id}}.dev`, `{{app_id}}.stg`, and `{{app_id}}`.  

These will render correctly per-project when the brick is generated.

---

